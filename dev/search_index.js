var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/#Visualizations","page":"Tutorials","title":"Visualizations","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Quasiprobability distributions of Gaussian states can be visualized with Makie.jl. Gabs.jl currently has support for the following distributions, which can be called with the keyword argument dist:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"wigner\nwignerchar","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Below is a code example that plots the wigner distribution of a vacuum state:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Gabs, CairoMakie\nbasis = QuadPairBasis(1)\nstate = vacuumstate(basis)\nq, p = collect(-5.0:0.5:5.0), collect(-5.0:0.5:5.0) # phase space coordinates\nheatmap(q, p, state, dist = :wigner)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Of course, more plotting sugar can be added to this example with internal Makie attributes:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Gabs, CairoMakie\nbasis = QuadPairBasis(1)\nstate = vacuumstate(basis)\nq, p = collect(-5.0:0.5:5.0), collect(-5.0:0.5:5.0) # phase space coordinates\nfig = Figure(fontsize=15, size = (375, 300), fonts = (; regular=\"CMU Serif\"))\nax = Axis(fig[1,1], xlabel = L\"q\", ylabel = L\"p\")\nhm = heatmap!(ax, q, p, state, dist = :wigner, colormap = :heat)\nColorbar(fig[1,2], hm)\nfig","category":"page"},{"location":"tutorials/#Using-Custom-Arrays","page":"Tutorials","title":"Using Custom Arrays","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Types such as GaussianState, GaussianUnitary, and GaussianChannel are agnostic array wrappers, so they can hold any custom array that exists in the Julia ecosystem. Operations in Gabs.jl preserve these custom array types, provided they follow the AbstractArray interface.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let's explore this feature in detail, using StaticArrays.jl and SparseArrays.jl as a case study. To create a coherent state that wraps around pure Julia arrays, the function coherentstate can be called with a single complex argument:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"julia> coherentstate(QuadPairBasis(1), 1.0-im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n  2.0\n -2.0\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Here, a GaussianState object containing a Vector{Float64} of size two (mean vector) and a Matrix{Float64} of size two by two (covariance matrix) was initialized. If we want to potentially optimize and boost the performance of our code, then one approach would be to wrap our GaussianState around different array types, for instance, an SVector from StaticArrays.jl or a SparseVector from SparseArrays.jl. Any defined method in Gabs.jl that (i) creates a custom type or (ii) transforms a custom type can specify an array type in its first (and second) arguments. Let's see an example with StaticArrays.jl:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"julia> using StaticArrays\n\njulia> state = coherentstate(SVector{2}, SMatrix{2,2}, QuadPairBasis(1), 1.0-im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element SVector{2, Float64} with indices SOneTo(2):\n  2.0\n -2.0\ncovariance: 2×2 SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):\n 1.0  0.0\n 0.0  1.0\n\njulia> tp = state ⊗ state\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element SVector{4, Float64} with indices SOneTo(4):\n  2.0\n -2.0\n  2.0\n -2.0\ncovariance: 4×4 SMatrix{4, 4, Float64, 16} with indices SOneTo(4)×SOneTo(4):\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> using SparseArrays\n\njulia> ptrace(SparseVector, SparseMatrixCSC, tp, 1)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element SparseVector{Float64, Int64} with 2 stored entries:\n  [1]  =  2.0\n  [2]  =  -2.0\ncovariance: 2×2 SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n 1.0   ⋅ \n  ⋅   1.0","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Importantly, methods that create or manipulate a Gaussian state, such as tensor and ptrace, preserve array types, but can also opt for a different array type.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"note: Note\nIf you have an array wrapper that initializes both vectors and matrices, then you can specify the array type with a single argument. For instance, to initialize a state that contains Arrays holding numbers of type Float32 rather than Float64, simply pass Array{Float32} to any relevant Gabs.jl method:julia> state = displace(Array{Float32}, QuadPairBasis(1), 1.0-im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float32}:\n  2.0\n -2.0\nsymplectic: 2×2 Matrix{Float32}:\n 1.0  0.0\n 0.0  1.0","category":"page"},{"location":"tutorials/#Creating-Symbolic-Gaussian-States","page":"Tutorials","title":"Creating Symbolic Gaussian States","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Create Gaussian states with symbolic variables using Symbolics.jl:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"julia> using Symbolics\n\njulia> @variables r θ τ\n3-element Vector{Num}:\n r\n θ\n τ\n\njulia> b = QuadBlockBasis(2);\n\njulia> st = eprstate(b, r, θ)\nGaussianState for 2 modes.\n  symplectic basis: QuadBlockBasis\nmean: 4-element Vector{Num}:\n 0\n 0\n 0\n 0\ncovariance: 4×4 Matrix{Num}:\n         cosh(2r)  -cos(θ)*sinh(2r)                 0  -sinh(2r)*sin(θ)\n -cos(θ)*sinh(2r)          cosh(2r)  -sinh(2r)*sin(θ)                 0\n                0  -sinh(2r)*sin(θ)          cosh(2r)   cos(θ)*sinh(2r)\n -sinh(2r)*sin(θ)                 0   cos(θ)*sinh(2r)          cosh(2r)\n\njulia> op = beamsplitter(b, τ)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadBlockBasis\ndisplacement: 4-element Vector{Num}:\n 0\n 0\n 0\n 0\nsymplectic: 4×4 Matrix{Num}:\n sqrt(1 - τ)      sqrt(τ)            0            0\n    -sqrt(τ)  sqrt(1 - τ)            0            0\n           0            0  sqrt(1 - τ)      sqrt(τ)\n           0            0     -sqrt(τ)  sqrt(1 - τ)\n\njulia> newst = ptrace(op * st, 1);","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Use Latexify to render the covariance matrix of newst in LaTeX with the command latexify(newst.covar) |> print:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"beginequation\nleft\nbeginarraycc\nleft( coshleft( 2 r right) sqrt1 - tau + cosleft( theta right) sinhleft( 2 r right) sqrttau right) sqrt1 - tau - left(  - sqrttau coshleft( 2 r right) - cosleft( theta right) sinhleft( 2 r right) sqrt1 - tau right) sqrttau  2 sinhleft( 2 r right) sinleft( theta right) sqrttau sqrt1 - tau \n2 sinhleft( 2 r right) sinleft( theta right) sqrttau sqrt1 - tau  left( coshleft( 2 r right) sqrt1 - tau - cosleft( theta right) sinhleft( 2 r right) sqrttau right) sqrt1 - tau - left(  - sqrttau coshleft( 2 r right) + cosleft( theta right) sinhleft( 2 r right) sqrt1 - tau right) sqrttau \nendarray\nright\nendequation","category":"page"},{"location":"tutorials/#GPU-Acceleration","page":"Tutorials","title":"GPU Acceleration","text":"","category":"section"},{"location":"tutorials/#Multithreading","page":"Tutorials","title":"Multithreading","text":"","category":"section"},{"location":"tutorials/#Benchmarking-and-Profiling","page":"Tutorials","title":"Benchmarking and Profiling","text":"","category":"section"},{"location":"intro/#intro","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"Gabs is a numerical tooling package for simulating Gaussian quantum information. Gaussian states and operators have the convenient property that they can be characterized by low-dimensional matrices in the phase space representation. Thus, a large class of continuous variable quantum information can be efficiently simulated on a classical computer. Gabs provides a high-level Julia interface for performing such efficient simulations in a straightforward manner.","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"In the sections below, a getting started tutorial is provided to introduce the capabilities of Gabs. The rest of the documentation is structured as follows:","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"Manual - an overview of the package types and inner-workings,\nTutorials - explanations for using particular features of the library,\nGaussian Zoos - a description of predefined Gaussian states and operators,\nAPI - the full API of the library,\nSuggested Readings and References - publications and learning resources on Gaussian quantum information.","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"note: Note\nThis documentation assumes familiarity with linear algebra and quantum information. Introductory books and tutorials for these topics are provided in the Suggested Readings and References page.","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"tip: Contributing\nAny contribution to Gabs is welcome! Feature suggestions, pull requests, and bug reports can be submitted on Github. The maintainers of Gabs subscribe to the Julia Community Standards.","category":"page"},{"location":"intro/#Installation","page":"Getting Started with Gabs","title":"Installation","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"To install Gabs.jl, start Julia and run the following command:","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"using Pkg\nPkg.add(\"Gabs\")","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"To use the package, run the command","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"using Gabs","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"Now, the entire library is loaded into the current workspace, with access to its high-level interface and predefined objects.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Simply put, Gabs is a package for creating and transforming Gaussian bosonic systems. This section discusses the \"lower level\" tools for simulating such phenomena, with mathematical explanations when appropriate. For comprehensive reviews of Gaussian quantum information, see the suggested readings page.","category":"page"},{"location":"manual/#The-Symplectic-Formalism","page":"Manual","title":"The Symplectic Formalism","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The underlying geometry of Gaussian informatics in the phase space is symplectic. From the basic canonical commutation relations (CCRs) of quantized continuous variable systems, manifestations of the symplectic group textSp(2N mathbbR) appear everywhere. In Gabs, symplectic basis types must be defined from the beginning. Here's how they are laid out in this library:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"canonical ordering symplectic form basis type\n(hatx_1 hatp_1 cdots hatx_N hatp_N) beginpmatrix 0  1  - 1  0 endpmatrix otimes mathbfI_N QuadPairBasis\n(hatx_1 cdots hatx_N hatp_1 cdots hatp_N) beginpmatrix 0  mathbfI_N  -mathbfI_N  0 endpmatrix QuadBlockBasis","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Each symplectic basis type is wrapped around the number of bosonic modes N. We can compose a larger symplectic basis with directsum or ⊕, the direct sum symbol which can be typed in the Julia REPL as \\oplus<TAB>:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> b = QuadPairBasis(2)\nQuadPairBasis(2)\n\njulia> b ⊕ b\nQuadPairBasis(4)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Of course, this type of behavior will occur implicitly when we take tensor products of Gaussian states and operators, as discussed in the following sections.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nA matrix mathbfS of size 2Ntimes 2N is symplectic when it satisfies the relation mathbfS mathbfOmega mathbfS^textT = mathbfOmega where mathbfOmega is an invertible skew-symmetric matrix known as the symplectic form.","category":"page"},{"location":"manual/#Gaussian-States","page":"Manual","title":"Gaussian States","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The star of this package is the GaussianState type, which allows us to initialize and manipulate a phase space description of an arbitrary Gaussian state.","category":"page"},{"location":"manual/#Gabs.GaussianState-manual","page":"Manual","title":"Gabs.GaussianState","text":"Defines a Gaussian state for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic basis for Gaussian state.\nmean: The mean vector of length 2N.\ncovar: The covariance matrix of size 2N x 2N.\nħ = 2: Reduced Planck's constant.\n\nExample\n\njulia> coherentstate(QuadPairBasis(1), 1.0+im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 2.0\n 2.0\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"Functions to create instances of elementary Gaussian states are provided as part of the package API.  Listed below are supported predefined Gaussian states:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"vacuumstate\nthermalstate\ncoherentstate\nsqueezedstate\neprstate","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Detailed discussions and mathematical descriptions for each of these states are given in the Gaussian Zoos page.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nIn Gabs, the default convention hbar = 2 is used for the commutation relation hatx hatp = ihbar. To change this convention, pass a new value to ħ as a keyword argument in any predefined method that creates a Gaussian object. For instance, to change the convention to ħ = 1 for a coherent state, call coherentstate(basis, α, ħ = 1). This is a more performant and safer approach compared to setting a global variable in a package. An error will be thrown for operations between Gaussian objects with different ħ conventions.","category":"page"},{"location":"manual/#Gaussian-Unitaries","page":"Manual","title":"Gaussian Unitaries","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To transform Gaussian states into Gaussian states, we need Gaussian maps. Let's begin with the simplest Gaussian transformation, a unitary transformation, which can be created with the GaussianUnitary type:","category":"page"},{"location":"manual/#Gabs.GaussianUnitary-manual","page":"Manual","title":"Gabs.GaussianUnitary","text":"Defines a Gaussian unitary for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic basis for Gaussian unitary.\ndisp: The displacement vector of length 2N.\nsymplectic: The symplectic matrix of size 2N x 2N.\nħ = 2: Reduced Planck's constant.\n\nMathematical description of a Gaussian unitary\n\nAn N-mode Gaussian unitary, is a unitary operator characterized by a displacement vector d of length 2N and symplectic matrix S of size 2N x 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian unitary transformation on a Gaussian state is described by its maps on the statistical moments x̄ and V of the Gaussian state: x̄ → Sx̄ + d and V → SVSᵀ.\n\nExample\n\njulia> displace(QuadPairBasis(1), 1.0+im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 2.0\n 2.0\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"This is a rather clean way to characterize a large group of Gaussian transformations on an N-mode Gaussian bosonic system. As long as we have a displacement vector of size 2N and symplectic matrix of size 2N x 2N, we can create a Gaussian transformation. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This library has a number of predefined Gaussian unitaries, which are listed below:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"displace\nsqueeze\ntwosqueeze\nphaseshift\nbeamsplitter","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Detailed discussions and mathematical descriptions for each of these unitaries are given in the Gaussian Zoos page.","category":"page"},{"location":"manual/#Gaussian-Channels","page":"Manual","title":"Gaussian Channels","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Noisy bosonic channels are an important model for describing the interaction between a Gaussian state and its environment. Similar to Gaussian unitaries, Gaussian channels are linear bosonic channels that map Gaussian states to Gaussian states. Such objects can be created with the GaussianChannel type:","category":"page"},{"location":"manual/#Gabs.GaussianChannel-manual","page":"Manual","title":"Gabs.GaussianChannel","text":"Defines a Gaussian channel for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic representation for Gaussian channel.\ndisp: The displacement vector of length 2N.\ntransform: The transformation matrix of size 2N x 2N.\nnoise: The noise matrix of size 2N x 2N.\nħ = 2: Reduced Planck's constant.\n\nMathematical description of a Gaussian channel\n\nAn N-mode Gaussian channel is an operator characterized by a displacement vector d of length 2N, as well as a transformation matrix T and noise matrix N of size 2N x 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian channel action on a Gaussian state is described by its maps on the statistical moments x̄ and V of the Gaussian state: x̄ → Tx̄ + d and V → TVTᵀ + N.\n\nExample\n\njulia> noise = [1.0 -3.0; 4.0 2.0];\n\njulia> displace(QuadPairBasis(1), 1.0+im, noise)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 2.0\n 2.0\ntransform: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\nnoise: 2×2 Matrix{Float64}:\n 1.0  -3.0\n 4.0   2.0\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"Listed below are a list of predefined Gaussian channels supported by Gabs:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"attenuator\namplifier","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nAny predefined Gaussian unitary method can be called with an additional noise matrix to create a GaussianChannel object. For instance, a noisy displacement operator can be called with displace as follows:julia> basis = QuadPairBasis(1);\n\njulia> noise = [1.0 -2.0; 4.0 -3.0];\n\njulia> displace(basis, 1.0-im, noise)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n  2.0\n -2.0\ntransform: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\nnoise: 2×2 Matrix{Float64}:\n 1.0  -2.0\n 4.0  -3.0","category":"page"},{"location":"manual/#Actions","page":"Manual","title":"Actions","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Out-of-place actions of Gaussian unitaries and Gaussian channels on Gaussian states are called with *, while in-place ones are called with apply!:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> basis = QuadBlockBasis(2); state = vacuumstate(basis);\n\njulia> un = squeeze(basis, 1.0, 2.0)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadBlockBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  2.03214   0.0      -1.06861   0.0\n  0.0       2.03214   0.0      -1.06861\n -1.06861   0.0       1.05402   0.0\n  0.0      -1.06861   0.0       1.05402\n\njulia> un * state\nGaussianState for 2 modes.\n  symplectic basis: QuadBlockBasis\nmean: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n  5.2715    0.0      -3.29789   0.0\n  0.0       5.2715    0.0      -3.29789\n -3.29789   0.0       2.25289   0.0\n  0.0      -3.29789   0.0       2.25289\n\njulia> ch = attenuator(basis, 0.25, 5)\nGaussianChannel for 2 modes.\n  symplectic basis: QuadBlockBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ntransform: 4×4 Matrix{Float64}:\n 0.968912  0.0       0.0       0.0\n 0.0       0.968912  0.0       0.0\n 0.0       0.0       0.968912  0.0\n 0.0       0.0       0.0       0.968912\nnoise: 4×4 Matrix{Float64}:\n 0.306044  0.0       0.0       0.0\n 0.0       0.306044  0.0       0.0\n 0.0       0.0       0.306044  0.0\n 0.0       0.0       0.0       0.306044\n\njulia> apply!(state, ch)\nGaussianState for 2 modes.\n  symplectic basis: QuadBlockBasis\nmean: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n 1.24483  0.0      0.0      0.0\n 0.0      1.24483  0.0      0.0\n 0.0      0.0      1.24483  0.0\n 0.0      0.0      0.0      1.24483","category":"page"},{"location":"manual/#Tensor-Products","page":"Manual","title":"Tensor Products","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"If we were operating in the state (Fock) space, and wanted to describe multi-mode Gaussian states, we would take the tensor product of multiple density operators. That method, however, is quite computationally expensive and requires a finite truncation of the Fock basis. To create such state vector simulations, we recommend using the QuantumOptics.jl library. For our purposes in the phase space, we efficiently create multi-mode Gaussian systems via direct sum, which corresponds to a tensor product of infinite-dimensional Hilbert spaces. A tensor product of Gaussian states can be called with either tensor or ⊗, the Kronecker product symbol which can be typed in the Julia REPL as \\otimes<TAB>. Take the following example, where we produce a 3-mode Gaussian state that consists of a coherent state, vacuumstate, and squeezed state:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> basis = QuadPairBasis(1);\n\njulia> coherentstate(basis, -1.0+im) ⊗ vacuumstate(basis) ⊗ squeezedstate(basis, 0.25, pi/4)\nGaussianState for 3 modes.\n  symplectic basis: QuadPairBasis\nmean: 6-element Vector{Float64}:\n -2.0\n  2.0\n  0.0\n  0.0\n  0.0\n  0.0\ncovariance: 6×6 Matrix{Float64}:\n 1.0  0.0  0.0  0.0   0.0        0.0\n 0.0  1.0  0.0  0.0   0.0        0.0\n 0.0  0.0  1.0  0.0   0.0        0.0\n 0.0  0.0  0.0  1.0   0.0        0.0\n 0.0  0.0  0.0  0.0   0.759156  -0.36847\n 0.0  0.0  0.0  0.0  -0.36847    1.4961","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that in the above example, we defined the symplectic basis to be of type QuadPairBasis. If we wanted the canonical field operators to be ordered blockwise, then we would call QuadBlockBasis instead:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> basis = QuadBlockBasis(1);\n\njulia> coherentstate(basis, -1.0+im) ⊗ vacuumstate(basis) ⊗ squeezedstate(basis, 0.25, pi/4)\nGaussianState for 3 modes.\n  symplectic basis: QuadBlockBasis\nmean: 6-element Vector{Float64}:\n -2.0\n  0.0\n  0.0\n  2.0\n  0.0\n  0.0\ncovariance: 6×6 Matrix{Float64}:\n 1.0  0.0   0.0       0.0  0.0   0.0\n 0.0  1.0   0.0       0.0  0.0   0.0\n 0.0  0.0   0.759156  0.0  0.0  -0.36847\n 0.0  0.0   0.0       1.0  0.0   0.0\n 0.0  0.0   0.0       0.0  1.0   0.0\n 0.0  0.0  -0.36847   0.0  0.0   1.4961","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"These tensor product methods are also available for Gaussian unitaries and channels:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> basis = QuadBlockBasis(1);\n\njulia> squeeze(basis, 2.0, pi/3) ⊗ phaseshift(basis, pi/6)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadBlockBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  1.94877   0.0       -3.14095  0.0\n  0.0       0.866025   0.0      0.5\n -3.14095   0.0        5.57563  0.0\n  0.0      -0.5        0.0      0.866025","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For applying the same predefined operator to a multi-mode system, simply call the operator on the corresponding multi-mode basis. For instance, if we wanted to apply a phase shift of π/4 to a three-mode Gaussian system, then we would create the following operation:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> basis = QuadPairBasis(3);\n\njulia> phaseshift(basis, pi/4)\nGaussianUnitary for 3 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 6-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 6×6 Matrix{Float64}:\n  0.707107  0.707107   0.0       0.0        0.0       0.0\n -0.707107  0.707107   0.0       0.0        0.0       0.0\n  0.0       0.0        0.707107  0.707107   0.0       0.0\n  0.0       0.0       -0.707107  0.707107   0.0       0.0\n  0.0       0.0        0.0       0.0        0.707107  0.707107\n  0.0       0.0        0.0       0.0       -0.707107  0.707107","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If, instead we wanted to apply phase shifts of π/3, π/4, and π/5 to the respective-modes of a three-mode Gaussian system, then we would dispatch phaseshift on a vector of the phase shifts:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> basis = QuadPairBasis(3);\n\njulia> phaseshift(basis, [pi/3, pi/4, pi/5])\nGaussianUnitary for 3 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 6-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 6×6 Matrix{Float64}:\n  0.5       0.866025   0.0       0.0        0.0       0.0\n -0.866025  0.5        0.0       0.0        0.0       0.0\n  0.0       0.0        0.707107  0.707107   0.0       0.0\n  0.0       0.0       -0.707107  0.707107   0.0       0.0\n  0.0       0.0        0.0       0.0        0.809017  0.587785\n  0.0       0.0        0.0       0.0       -0.587785  0.809017","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Similar properties hold for Gaussian channels and states. Let's see some examples for multi-mode coherent states:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> basis = QuadPairBasis(3);\n\njulia> coherentstate(basis, 1.0-im)\nGaussianState for 3 modes.\n  symplectic basis: QuadPairBasis\nmean: 6-element Vector{Float64}:\n  2.0\n -2.0\n  2.0\n -2.0\n  2.0\n -2.0\ncovariance: 6×6 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0\n\njulia> coherentstate(basis, [1.0-im, 2.0-2.0im, 3.0-3.0im])\nGaussianState for 3 modes.\n  symplectic basis: QuadPairBasis\nmean: 6-element Vector{Float64}:\n  2.0\n -2.0\n  4.0\n -4.0\n  6.0\n -6.0\ncovariance: 6×6 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0","category":"page"},{"location":"manual/#Partial-Traces","page":"Manual","title":"Partial Traces","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Partial traces of Gaussian states can be performed with ptrace. For tracing  out a single-mode, call an integer corresponding to the mode of choice in a multi-mode Gaussian system. For tracing out several modes, call instead a vector of integers.  Let's see some examples:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> basis = QuadPairBasis(2);\n\njulia> state = coherentstate(basis, [1.0-im, 2.0-2.0im]) ⊗ eprstate(basis, 2.0, pi/3)\nGaussianState for 4 modes.\n  symplectic basis: QuadPairBasis\nmean: 8-element Vector{Float64}:\n  2.0\n -2.0\n  4.0\n -4.0\n  0.0\n  0.0\n  0.0\n  0.0\ncovariance: 8×8 Matrix{Float64}:\n 1.0  0.0  0.0  0.0    0.0       0.0       0.0       0.0\n 0.0  1.0  0.0  0.0    0.0       0.0       0.0       0.0\n 0.0  0.0  1.0  0.0    0.0       0.0       0.0       0.0\n 0.0  0.0  0.0  1.0    0.0       0.0       0.0       0.0\n 0.0  0.0  0.0  0.0   27.3082    0.0     -13.645   -23.6338\n 0.0  0.0  0.0  0.0    0.0      27.3082  -23.6338   13.645\n 0.0  0.0  0.0  0.0  -13.645   -23.6338   27.3082    0.0\n 0.0  0.0  0.0  0.0  -23.6338   13.645     0.0      27.3082\n\njulia> ptrace(state, 1)\nGaussianState for 3 modes.\n  symplectic basis: QuadPairBasis\nmean: 6-element Vector{Float64}:\n  4.0\n -4.0\n  0.0\n  0.0\n  0.0\n  0.0\ncovariance: 6×6 Matrix{Float64}:\n 1.0  0.0    0.0       0.0       0.0       0.0\n 0.0  1.0    0.0       0.0       0.0       0.0\n 0.0  0.0   27.3082    0.0     -13.645   -23.6338\n 0.0  0.0    0.0      27.3082  -23.6338   13.645\n 0.0  0.0  -13.645   -23.6338   27.3082    0.0\n 0.0  0.0  -23.6338   13.645     0.0      27.3082\n\njulia> ptrace(state, [1, 4])\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element Vector{Float64}:\n  4.0\n -4.0\n  0.0\n  0.0\ncovariance: 4×4 Matrix{Float64}:\n 1.0  0.0   0.0      0.0\n 0.0  1.0   0.0      0.0\n 0.0  0.0  27.3082   0.0\n 0.0  0.0   0.0     27.3082","category":"page"},{"location":"manual/#Symplectic-Analysis","page":"Manual","title":"Symplectic Analysis","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Gabs provides different tools for analyzing symplectic transformations and properties of Gaussian states and operators. Under the hood, the aforementioned types such  as GaussianState, GaussianUnitary, and GaussianChannel keep track of symplectic bases, i.e., ordering of bosonic mode operators. To change symplectic bases, simply call changebasis. As an example, consider the phase shift operator, defined by the quadrature transformations","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"hatx to cos(theta) hatx + sin(theta) hatp qquad hatp to -sin(theta) hatx + cos(theta) hatp","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The symplectic transformation corresponding to the action of a tensor product of phase shift operators on a bosonic system is dependent on the ordering of the bosonic mode observables, so it is useful to swap symplectic bases. Consider a simple example for a two-mode system:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> op = phaseshift(QuadBlockBasis(2), 0.5)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadBlockBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  0.877583   0.0       0.479426  0.0\n  0.0        0.877583  0.0       0.479426\n -0.479426   0.0       0.877583  0.0\n  0.0       -0.479426  0.0       0.877583\n\njulia> changebasis(QuadPairBasis, op)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  0.877583  0.479426   0.0       0.0\n -0.479426  0.877583   0.0       0.0\n  0.0       0.0        0.877583  0.479426\n  0.0       0.0       -0.479426  0.877583","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Various symplectic decompositions are supported in Gabs through the symplectic linear algebra package SymplecticFactorizations.jl. Particularly important ones are the Williamson decomposition (williamson), Bloch-Messiah/Euler decomposition (blochmessiah), and the symplectic polar decomposition (polar):","category":"page"},{"location":"manual/#SymplecticFactorizations.williamson-manual","page":"Manual","title":"SymplecticFactorizations.williamson","text":"williamson(state::GaussianState) -> Williamson\n\nCompute the williamson decomposition of the covar field of a GaussianState object and return a Williamson object.\n\nA symplectic matrix S and symplectic spectrum spectrum can be obtained via F.S and F.spectrum.\n\nIterating the decomposition produces the components S and spectrum.\n\nTo compute only the symplectic spectrum of a Gaussian state, call sympspectrum.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SymplecticFactorizations.blochmessiah-manual","page":"Manual","title":"SymplecticFactorizations.blochmessiah","text":"blochmessiah(state::GaussianUnitary) -> BlochMessiah\n\nCompute the Bloch-Messiah/Euler decomposition of the symplectic field of a GaussianUnitary and return a BlockMessiah object.\n\nThe orthogonal symplectic matrices O and Q as well as the singular values values can be obtained via F.O, F.Q, and F.values, respectively.\n\nIterating the decomposition produces the components O, values, and Q, in that order.\n\n\n\n\n\n","category":"function"},{"location":"manual/#SymplecticFactorizations.polar-manual","page":"Manual","title":"SymplecticFactorizations.polar","text":"polar(state::GaussianUnitary) -> Polar\n\nCompute the Polar decomposition of the symplectic field of a GaussianUnitary object and return a Polar object.\n\nO and P can be obtained from the factorization F via F.O and F.P, such that S = O * P. For the symplectic polar decomposition case, O is an orthogonal symplectic matrix and P is a positive-definite symmetric symplectic matrix.\n\nIterating the decomposition produces the components O and P.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's see an example with the Williamson decomposition:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Gabs, LinearAlgebra\nstate = randstate(QuadBlockBasis(1))\nF = williamson(state)\nisapprox(Diagonal(repeat(F.spectrum, 2)), F.S * state.covar * F.S', atol = 1e-12)\nS, spectrum = F; # destructuring via iteration\nS == F.S && spectrum == F.spectrum\nissymplectic(QuadBlockBasis(1), S, atol = 1e-12)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In the last line of code, we used the symplectic check issymplectic. In general, we can check if a state or operator is Gaussian with isgaussian.","category":"page"},{"location":"zoos/#Gaussian-Zoos","page":"Gaussian Zoos","title":"Gaussian Zoos","text":"","category":"section"},{"location":"zoos/#State-Zoo","page":"Gaussian Zoos","title":"State Zoo","text":"","category":"section"},{"location":"zoos/#Gabs.vacuumstate-zoos","page":"Gaussian Zoos","title":"Gabs.vacuumstate","text":"vacuumstate([Tm=Vector{Float64}, Tc=Matrix{Float64}], basis::SymplecticBasis)\n\nGaussian state with zero photons, known as the vacuum state. The symplectic representation is defined by basis.\n\nMathematical description of a vacuum state\n\nA vacuum state |0⟩ is characterized by the zero mean vector and covariance matrix (ħ/2)I.\n\nExample\n\njulia> vacuumstate(QuadPairBasis(1))\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.thermalstate-zoos","page":"Gaussian Zoos","title":"Gabs.thermalstate","text":"thermalstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, photons<:Int)\n\nGaussian state at thermal equilibrium, known as the thermal state. The symplectic representation is defined by basis. The mean photon number of the state is given by photons.\n\nMathematical description of a thermal state\n\nA thermal state |n̄⟩, where n̄ is the mean number of photons, is characterized by the zero mean vector and covariance matrix ħ(n̄+1/2)I.\n\nExample\n\njulia> thermalstate(QuadPairBasis(1), 4)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 9.0  0.0\n 0.0  9.0\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.coherentstate-zoos","page":"Gaussian Zoos","title":"Gabs.coherentstate","text":"coherentstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, alpha<:Number)\n\nGaussian state that is the quantum analogue of a monochromatic electromagnetic field, known as the coherent state. The symplectic representation is defined by basis. The complex amplitude of the state is given by alpha.\n\nMathematical description of a coherent state\n\nA coherent state |α⟩, where α is the complex amplitude, is characterized by the mean vector √2ħ [real(α), imag(α)] and covariance matrix (ħ/2)I.\n\nExample\n\njulia> coherentstate(QuadPairBasis(1), 1.0+im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 2.0\n 2.0\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.squeezedstate-zoos","page":"Gaussian Zoos","title":"Gabs.squeezedstate","text":"squeezedstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, r<:Real, theta<:Real)\n\nGaussian state with quantum uncertainty in its phase and amplitude, known as the squeezed state. The symplectic representation is defined by basis. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of a squeezed state\n\nA squeezed state |r, θ⟩, where r is the amplitude squeezing parameter and θ is the phase squeezing parameter, is characterized by the zero mean vector and covariance matrix (ħ/2) (cosh(2r)I - sinh(2r)R(θ)), where R(θ) is the rotation matrix.\n\nExample\n\njulia> squeezedstate(QuadPairBasis(1), 0.5, pi/4)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n  0.712088  -0.830993\n -0.830993   2.37407\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.eprstate-zoos","page":"Gaussian Zoos","title":"Gabs.eprstate","text":"eprstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, r<:Real, theta<:Real)\n\nGaussian state that is a two-mode squeezed state, known as the Einstein-Podolski-Rosen (EPR) state. The symplectic representation is defined by basis. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of an EPR state\n\nAn EPR state |r, θ⟩ₑₚᵣ, where r is the amplitude squeezing parameter and θ is the phase squeezing parameter, is characterized by the zero mean vector and covariance matrix (ħ/2)[cosh(2r)I -sinh(2r)R(θ); -sinh(2r)R(θ) cosh(2r)I],  where R(θ) is the rotation matrix.\n\nExample\n\njulia> eprstate(QuadPairBasis(2), 0.5, pi/4)\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n  1.54308    0.0       -0.830993  -0.830993\n  0.0        1.54308   -0.830993   0.830993\n -0.830993  -0.830993   1.54308    0.0\n -0.830993   0.830993   0.0        1.54308\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Operator-Zoo","page":"Gaussian Zoos","title":"Operator Zoo","text":"","category":"section"},{"location":"zoos/#Gabs.displace-zoos","page":"Gaussian Zoos","title":"Gabs.displace","text":"displace([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, alpha<:Number)\ndisplace([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, alpha<:Number, noise::Ts)\n\nGaussian operator that displaces the vacuum state into a coherent state, known as the displacement operator. The symplectic representation is given by basis. The complex amplitude is given by alpha. Noise can be added to the operation with noise.\n\nMathematical description of a displacement operator\n\nA displacement operator D(α) is defined by the operation D(α)|0⟩ = |α⟩, where α is a complex amplitude. The operator D(α)  is characterized by the displacement vector √2ħ [real(α), imag(α)]  and symplectic matrix I.\n\nExample\n\njulia> displace(QuadPairBasis(1), 1.0+im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 2.0\n 2.0\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.squeeze-zoos","page":"Gaussian Zoos","title":"Gabs.squeeze","text":"squeeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real)\nsqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes the vacuum state into a squeezed state, known as the squeezing operator. The symplectic representation is given by basis. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a squeezing operator\n\nA squeeze operator S(r, θ) is defined by the operation S(r, θ)|0⟩ = |r, θ⟩, where r and θ are the real amplitude and phase parameters,  respectively. The operator S(r, θ) is characterized by  the zero displacement vector and symplectic matrix cosh(r)I - sinh(r)R(θ), where R(θ) is the rotation matrix.\n\nExample\n\njulia> squeeze(QuadPairBasis(1), 0.25, pi/4)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n  0.852789  -0.178624\n -0.178624   1.21004\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.twosqueeze-zoos","page":"Gaussian Zoos","title":"Gabs.twosqueeze","text":"twosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real)\ntwosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes a two-mode vacuum state into a two-mode squeezed state, known as the two-mode squeezing operator. The symplectic representation is given by basis. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a two-mode squeezing operator\n\nA two-mode squeeze operator S₂(r, θ) is defined by the operation S₂(r, θ)|0⟩ = |r, θ⟩, where r and θ are the real amplitude and phase parameters, respectively. The operator  S₂(r, θ) is characterized by the zero displacement vector and symplectic matrix [cosh(r)I -sinh(r)R(θ); -sinh(r)R(θ) cosh(r)I], where R(θ) is the rotation matrix.\n\nExample\n\njulia> twosqueeze(QuadPairBasis(2), 0.25, pi/4)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  1.03141    0.0       -0.178624  -0.178624\n  0.0        1.03141   -0.178624   0.178624\n -0.178624  -0.178624   1.03141    0.0\n -0.178624   0.178624   0.0        1.03141\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.phaseshift-zoos","page":"Gaussian Zoos","title":"Gabs.phaseshift","text":"phaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, theta<:Real)\nphaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, theta<:Real, noise::Ts)\n\nGaussian operator that rotates the phase of a given Gaussian mode by theta, as the phase shift operator. The symplectic representation is given by basis. Noise can be added to the operation with noise.\n\nMathematical description of a phase shift operator\n\nA phase shift operator is defined by the operation U(θ) = exp(-iθâᵗâ), where θ is the phase parameter, and âᵗ and â are the raising and lowering operators, respectively. The operator U(θ) is characterized by  the zero displacement vector and symplectic matrix [cos(θ) sin(θ); -sin(θ) cos(θ)].\n\nExample\n\njulia> phaseshift(QuadPairBasis(1), 3pi/4)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n -0.707107   0.707107\n -0.707107  -0.707107\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.beamsplitter-zoos","page":"Gaussian Zoos","title":"Gabs.beamsplitter","text":"beamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, transmit<:Real)\nbeamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, transmit<:Real, noise::Ts)\n\nGaussian operator that serves as the beam splitter transformation of a two-mode Gaussian state, known as the beam splitter operator. The symplectic representation is given by basis. The transmittivity of the operator is given by transmit. Noise can be added to the operation with noise.\n\nMathematical description of a beam splitter operator\n\nA beam splitter operator B(τ) is defined by the operation B(τ) = exp(θ(âᵗb̂ - âb̂ᵗ)), where θ is defined by τ = cos²θ,  and â and b̂ are the annihilation operators of the two modes,  respectively. The operator B(τ) is characterized by  the zero displacement vector and symplectic matrix [√τI √(1-τ)I; -√(1-τ)I √τI].\n\nExample\n\njulia> beamsplitter(QuadPairBasis(2), 0.75)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  0.5        0.0       0.866025  0.0\n  0.0        0.5       0.0       0.866025\n -0.866025   0.0       0.5       0.0\n  0.0       -0.866025  0.0       0.5\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.attenuator-zoos","page":"Gaussian Zoos","title":"Gabs.attenuator","text":"attenuator([Td=Vector{Float64}, Tt=Matrix{Float64},] basis::SymplecticBasis, theta<:Real, n<:Int)\n\nGaussian channel describing the coupling of an input single mode Gaussian state and its environment via a beam splitter operation. The channel is paramatrized by beam splitter rotation angle theta and thermal noise n.\n\nMathematical description of an attenuator channel\n\nAn attenuator channel, E(θ, nₜₕ), where θ is the beam splitter rotation parameter and nₜₕ ≥ 1 is the thermal noise parameter, is characterized by the zero displacement vector, transformation matrix cos(θ)I, and noise matrix nₜₕsin²(θ)I.\n\nExample\n\njulia> attenuator(QuadPairBasis(1), pi/6, 3)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 0.866025  0.0\n 0.0       0.866025\nnoise: 2×2 Matrix{Float64}:\n 0.75  0.0\n 0.0   0.75\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.amplifier-zoos","page":"Gaussian Zoos","title":"Gabs.amplifier","text":"amplifier([Td=Vector{Float64}, Tt=Matrix{Float64},] basis::SymplecticBasis, r<:Real, n<:Int)\n\nGaussian channel describing the interaction of an input single mode Gaussian state and its environment via a two-mode squeezing operation. The channel is paramatrized by squeezing amplitude parameter r and thermal noise n.\n\nMathematical description of an amplifier channel\n\nAn amplifier channel, A(r, nₜₕ), where r is the squeezing amplitude parameter and nₜₕ ≥ 1 is the thermal noise parameter, is characterized by the zero displacement vector, transformation matrix cosh(r)I, and noise matrix nₜₕsinh²(r)I.\n\nExample\n\njulia> amplifier(QuadPairBasis(1), 2.0, 3)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 3.7622  0.0\n 0.0     3.7622\nnoise: 2×2 Matrix{Float64}:\n 39.4623   0.0\n  0.0     39.4623\n\n\n\n\n\n","category":"function"},{"location":"bibliography/#References","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"","category":"section"},{"location":"bibliography/#Tutorials-on-Gaussian-Quantum-Information","page":"Suggested Readings and References","title":"Tutorials on Gaussian Quantum Information","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Adesso, G.; Ragy, S. and Lee, A. R. (2014). Continuous Variable Quantum Information: Gaussian States and Beyond. Open Systems & Information Dynamics 21, 1440001.\n\n\n\nOlivares, S. (2011). Quantum optics in the phase space. The European Physical Journal Special Topics 203, 3–24.\n\n\n\nWang, X.-B.; Hiroshima, T.; Tomita, A. and Hayashi, M. (2007). Quantum information with Gaussian states. Physics Reports 448, 1–111.\n\n\n\nWeedbrook, C.; Pirandola, S.; Garcı́a-Patrón, R.; Cerf, N. J.; Ralph, T. C.; Shapiro, J. H. and Lloyd, S. (2012). Gaussian quantum information. Rev. Mod. Phys. 84, 621–669.\n\n\n\n","category":"page"},{"location":"bibliography/#Tutorials-and-Books-on-Quantum-Continuous-Variables","page":"Suggested Readings and References","title":"Tutorials and Books on Quantum Continuous Variables","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Braunstein, S. L. (2005). Squeezing as an irreducible resource. Phys. Rev. A 71, 055801.\n\n\n\nCerf, N. J.; Leuchs, G. and Polzik, E. S. (2007). Quantum Information with Continuous Variables of Atoms and Light (Imperial College Press).\n\n\n\nSerafini, A. (2023). Quantum Continuous Variables: A Primer of Theoretical Methods (CRC Press).\n\n\n\nWalschaers, M. (2021). Non-Gaussian Quantum States and Where to Find Them. PRX Quantum 2, 030204.\n\n\n\n","category":"page"},{"location":"bibliography/#Technical-Reviews-on-Quantum-Continuous-Variables","page":"Suggested Readings and References","title":"Technical Reviews on Quantum Continuous Variables","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Andersen, U.; Leuchs, G. and Silberhorn, C. (2010). Continuous-variable quantum information processing. Laser & Photonics Reviews 4, 337–354.\n\n\n\nCerf, N. J. and Grangier, P. (2007). From quantum cloning to quantum key distribution with continuous variables: a review (Invited). J. Opt. Soc. Am. B 24, 324–334.\n\n\n\nFukui, K. and Takeda, S. (2022). Building a large-scale quantum computer with continuous-variable optical technologies. Journal of Physics B: Atomic, Molecular and Optical Physics 55, 012001.\n\n\n\nGoldberg, A. Z.; Klimov, A. B.; Grassl, M.; Leuchs, G. and Sánchez-Soto, L. L. (2020). Extremal quantum states. AVS Quantum Science 2, 044701.\n\n\n\nJankowski, M.; Yanagimoto, R.; Ng, E.; Hamerly, R.; McKenna, T. P.; Mabuchi, H. and Fejer, M. M. (2024). Ultrafast second-order nonlinear photonics—from classical physics to non-Gaussian quantum dynamics: a tutorial. Adv. Opt. Photon. 16, 347–538.\n\n\n\nvan Loock, P. (2002). Quantum Communication with Continuous Variables. Fortschritte der Physik 50, 1177–1372.\n\n\n\nLvovsky, A. I. and Raymer, M. G. (2009). Continuous-variable optical quantum-state tomography. Rev. Mod. Phys. 81, 299–332.\n\n\n\nPirandola, S. and Mancini, S. (2006). Quantum teleportation with continuous variables: A survey. Laser Physics 16, 1418–1438.\n\n\n\n","category":"page"},{"location":"bibliography/#Seminal-Papers-related-to-Gaussian-Quantum-Information","page":"Suggested Readings and References","title":"Seminal Papers related to Gaussian Quantum Information","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Bartlett, S. D.; Sanders, B. C.; Braunstein, S. L. and Nemoto, K. (2002). Efficient Classical Simulation of Continuous Variable Quantum Information Processes. Phys. Rev. Lett. 88, 097904.\n\n\n\nBraunstein, S. L. (2005). Squeezing as an irreducible resource. Phys. Rev. A 71, 055801.\n\n\n\nDuan, L.-M.; Giedke, G.; Cirac, J. I. and Zoller, P. (2000). Entanglement Purification of Gaussian Continuous Variable Quantum States. Phys. Rev. Lett. 84, 4002–4005.\n\n\n\nEisert, J.; Scheel, S. and Plenio, M. B. (2002). Distilling Gaussian States with Gaussian Operations is Impossible. Phys. Rev. Lett. 89, 137903.\n\n\n\nEisert, J. and Plenio, M. B. (2002). Conditions for the Local Manipulation of Gaussian States. Phys. Rev. Lett. 89, 097901.\n\n\n\nFiurášek, J. (2002). Gaussian Transformations and Distillation of Entangled Gaussian States. Phys. Rev. Lett. 89, 137904.\n\n\n\nGiedke, G.; Wolf, M. M.; Krüger, O.; Werner, R. F. and Cirac, J. I. (2003). Entanglement of Formation for Symmetric Gaussian States. Phys. Rev. Lett. 91, 107901.\n\n\n\nGiedke, G. and Ignacio Cirac, J. (2002). Characterization of Gaussian operations and distillation of Gaussian states. Phys. Rev. A 66, 032316.\n\n\n\nGrosshans, F. and Grangier, P. (2002). Continuous Variable Quantum Cryptography Using Coherent States. Phys. Rev. Lett. 88, 057902.\n\n\n\nLloyd, S. and Braunstein, S. L. (1999). Quantum Computation over Continuous Variables. Phys. Rev. Lett. 82, 1784–1787.\n\n\n\nSimon, R.; Sudarshan, E. C. and Mukunda, N. (1988). Gaussian pure states in quantum mechanics and the symplectic group. Phys. Rev. A 37, 3028–3038.\n\n\n\nWenger, J.; Tualle-Brouri, R. and Grangier, P. (2004). Non-Gaussian Statistics from Individual Pulses of Squeezed Light. Phys. Rev. Lett. 92, 153601.\n\n\n\n","category":"page"},{"location":"bibliography/#Publications-on-Gaussian-Quantum-Measurements","page":"Suggested Readings and References","title":"Publications on Gaussian Quantum Measurements","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Cenni, M. F.; Lami, L.; Acín, A. and Mehboudi, M. (2022). Thermometry of Gaussian quantum systems using Gaussian measurements. Quantum 6, 743.\n\n\n\nKiukas, J. and Schultz, J. (2013). Informationally complete sets of Gaussian measurements. Journal of Physics A: Mathematical and Theoretical 46, 485303.\n\n\n\nMarco G. Genoni, L. L. and Serafini, A. (2016). Conditional and unconditional Gaussian quantum dynamics. Contemporary Physics 57, 331–349.\n\n\n\nZhang, J. (2018). Quantum measurement and preparation of Gaussian states. Ph.D. Thesis, Aarhus University.\n\n\n\n","category":"page"},{"location":"#Gabs.jl","page":"Gabs.jl","title":"Gabs.jl","text":"","category":"section"},{"location":"","page":"Gabs.jl","title":"Gabs.jl","text":"A numerical package for simulating Gaussian quantum information in the phase space representation.","category":"page"},{"location":"","page":"Gabs.jl","title":"Gabs.jl","text":"Visit the getting started page for an introduction to Gabs and its documentation.","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/#Gabs.GaussianChannel","page":"API","title":"Gabs.GaussianChannel","text":"Defines a Gaussian channel for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic representation for Gaussian channel.\ndisp: The displacement vector of length 2N.\ntransform: The transformation matrix of size 2N x 2N.\nnoise: The noise matrix of size 2N x 2N.\nħ = 2: Reduced Planck's constant.\n\nMathematical description of a Gaussian channel\n\nAn N-mode Gaussian channel is an operator characterized by a displacement vector d of length 2N, as well as a transformation matrix T and noise matrix N of size 2N x 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian channel action on a Gaussian state is described by its maps on the statistical moments x̄ and V of the Gaussian state: x̄ → Tx̄ + d and V → TVTᵀ + N.\n\nExample\n\njulia> noise = [1.0 -3.0; 4.0 2.0];\n\njulia> displace(QuadPairBasis(1), 1.0+im, noise)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 2.0\n 2.0\ntransform: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\nnoise: 2×2 Matrix{Float64}:\n 1.0  -3.0\n 4.0   2.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.GaussianLinearCombination","page":"API","title":"Gabs.GaussianLinearCombination","text":"GaussianLinearCombination{B<:SymplecticBasis,C,S}\n\nRepresents a linear combination of Gaussian states of the form Σᵢ cᵢ|ψᵢ⟩ where cᵢ are coefficients  and |ψᵢ⟩ are Gaussian states, all sharing the same symplectic basis and ħ value.\n\nFields\n\nbasis::B: Symplectic basis shared by all states\ncoeffs::Vector{C}: Complex coefficients for the linear combination  \nstates::Vector{S}: Vector of Gaussian states\nħ::Number: Reduced Planck's constant (must be same for all states)\n\nExamples\n\njulia> basis = QuadPairBasis(1) QuadPairBasis(1)\n\njulia> state1 = coherentstate(basis, 1.0) GaussianState for 1 mode.   symplectic basis: QuadPairBasis mean: 2-element Vector{Float64}:  2.0  0.0 covariance: 2×2 Matrix{Float64}:  1.0  0.0  0.0  1.0\n\njulia> state2 = coherentstate(basis, -1.0) GaussianState for 1 mode.   symplectic basis: QuadPairBasis mean: 2-element Vector{Float64}:  -2.0   0.0 covariance: 2×2 Matrix{Float64}:  1.0  0.0  0.0  1.0\n\njulia> cat_state = 0.5 * state1 + 0.5 * state2 GaussianLinearCombination with 2 terms for 1 mode.   symplectic basis: QuadPairBasis   ħ = 2   [1] 0.5 * GaussianState   [2] 0.5 * GaussianState\n\njulia> lcgs = GaussianLinearCombination([0.6, 0.8], [state1, state2]) GaussianLinearCombination with 2 terms for 1 mode.   symplectic basis: QuadPairBasis   ħ = 2   [1] 0.6 * GaussianState   [2] 0.8 * GaussianState\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.GaussianLinearCombination-Tuple{Vararg{Pair{<:Number, <:GaussianState}}}","page":"API","title":"Gabs.GaussianLinearCombination","text":"GaussianLinearCombination(pairs::Pair{<:Number,<:GaussianState}...)\n\nCreate a linear combination from coefficient => state pairs.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.GaussianLinearCombination-Tuple{Vector{<:Number}, Vector{<:GaussianState}}","page":"API","title":"Gabs.GaussianLinearCombination","text":"GaussianLinearCombination(coeffs::Vector{<:Number}, states::Vector{<:GaussianState})\n\nCreate a linear combination from separate vectors of coefficients and states.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.GaussianLinearCombination-Tuple{Vector{<:Tuple}}","page":"API","title":"Gabs.GaussianLinearCombination","text":"GaussianLinearCombination(pairs::Vector{<:Tuple})\n\nCreate a linear combination from a vector of (coefficient, state) tuples.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.GaussianLinearCombination-Union{Tuple{GaussianState{B, M, V}}, Tuple{V}, Tuple{M}, Tuple{B}} where {B, M, V}","page":"API","title":"Gabs.GaussianLinearCombination","text":"GaussianLinearCombination(state::GaussianState)\n\nCreate a linear combination containing a single Gaussian state with coefficient 1.0.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.GaussianState","page":"API","title":"Gabs.GaussianState","text":"Defines a Gaussian state for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic basis for Gaussian state.\nmean: The mean vector of length 2N.\ncovar: The covariance matrix of size 2N x 2N.\nħ = 2: Reduced Planck's constant.\n\nExample\n\njulia> coherentstate(QuadPairBasis(1), 1.0+im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 2.0\n 2.0\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.GaussianUnitary","page":"API","title":"Gabs.GaussianUnitary","text":"Defines a Gaussian unitary for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic basis for Gaussian unitary.\ndisp: The displacement vector of length 2N.\nsymplectic: The symplectic matrix of size 2N x 2N.\nħ = 2: Reduced Planck's constant.\n\nMathematical description of a Gaussian unitary\n\nAn N-mode Gaussian unitary, is a unitary operator characterized by a displacement vector d of length 2N and symplectic matrix S of size 2N x 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian unitary transformation on a Gaussian state is described by its maps on the statistical moments x̄ and V of the Gaussian state: x̄ → Sx̄ + d and V → SVSᵀ.\n\nExample\n\njulia> displace(QuadPairBasis(1), 1.0+im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 2.0\n 2.0\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.QuadBlockBasis","page":"API","title":"Gabs.QuadBlockBasis","text":"Defines a symplectic basis for a bosonic system of size nmodes in which the quadrature field operators are arranged blockwise.\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.QuadPairBasis","page":"API","title":"Gabs.QuadPairBasis","text":"Defines a symplectic basis for a bosonic system of size nmodes in which the quadrature field operators are arranged pairwise.\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.amplifier-Union{Tuple{M}, Tuple{R}, Tuple{N}, Tuple{Tt}, Tuple{Td}, Tuple{Type{Td}, Type{Tt}, Gabs.SymplecticBasis{N}, R, M}} where {Td, Tt, N<:Int64, R, M}","page":"API","title":"Gabs.amplifier","text":"amplifier([Td=Vector{Float64}, Tt=Matrix{Float64},] basis::SymplecticBasis, r<:Real, n<:Int)\n\nGaussian channel describing the interaction of an input single mode Gaussian state and its environment via a two-mode squeezing operation. The channel is paramatrized by squeezing amplitude parameter r and thermal noise n.\n\nMathematical description of an amplifier channel\n\nAn amplifier channel, A(r, nₜₕ), where r is the squeezing amplitude parameter and nₜₕ ≥ 1 is the thermal noise parameter, is characterized by the zero displacement vector, transformation matrix cosh(r)I, and noise matrix nₜₕsinh²(r)I.\n\nExample\n\njulia> amplifier(QuadPairBasis(1), 2.0, 3)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 3.7622  0.0\n 0.0     3.7622\nnoise: 2×2 Matrix{Float64}:\n 39.4623   0.0\n  0.0     39.4623\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.attenuator-Union{Tuple{M}, Tuple{R}, Tuple{N}, Tuple{Tt}, Tuple{Td}, Tuple{Type{Td}, Type{Tt}, Gabs.SymplecticBasis{N}, R, M}} where {Td, Tt, N<:Int64, R, M}","page":"API","title":"Gabs.attenuator","text":"attenuator([Td=Vector{Float64}, Tt=Matrix{Float64},] basis::SymplecticBasis, theta<:Real, n<:Int)\n\nGaussian channel describing the coupling of an input single mode Gaussian state and its environment via a beam splitter operation. The channel is paramatrized by beam splitter rotation angle theta and thermal noise n.\n\nMathematical description of an attenuator channel\n\nAn attenuator channel, E(θ, nₜₕ), where θ is the beam splitter rotation parameter and nₜₕ ≥ 1 is the thermal noise parameter, is characterized by the zero displacement vector, transformation matrix cos(θ)I, and noise matrix nₜₕsin²(θ)I.\n\nExample\n\njulia> attenuator(QuadPairBasis(1), pi/6, 3)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 0.866025  0.0\n 0.0       0.866025\nnoise: 2×2 Matrix{Float64}:\n 0.75  0.0\n 0.0   0.75\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.beamsplitter-Union{Tuple{R}, Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}, R}} where {Td, Ts, N<:Int64, R}","page":"API","title":"Gabs.beamsplitter","text":"beamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, transmit<:Real)\nbeamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, transmit<:Real, noise::Ts)\n\nGaussian operator that serves as the beam splitter transformation of a two-mode Gaussian state, known as the beam splitter operator. The symplectic representation is given by basis. The transmittivity of the operator is given by transmit. Noise can be added to the operation with noise.\n\nMathematical description of a beam splitter operator\n\nA beam splitter operator B(τ) is defined by the operation B(τ) = exp(θ(âᵗb̂ - âb̂ᵗ)), where θ is defined by τ = cos²θ,  and â and b̂ are the annihilation operators of the two modes,  respectively. The operator B(τ) is characterized by  the zero displacement vector and symplectic matrix [√τI √(1-τ)I; -√(1-τ)I √τI].\n\nExample\n\njulia> beamsplitter(QuadPairBasis(2), 0.75)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  0.5        0.0       0.866025  0.0\n  0.0        0.5       0.0       0.866025\n -0.866025   0.0       0.5       0.0\n  0.0       -0.866025  0.0       0.5\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.catstate","page":"API","title":"Gabs.catstate","text":"catstate(basis::SymplecticBasis, αs::AbstractVector, phases::AbstractVector=zeros(length(αs)); squeeze_params=nothing, ħ=2)\n\nCreate multi-mode general cat states as tensor products of single-mode cat states.\n\n\n\n\n\n","category":"function"},{"location":"API/#Gabs.catstate-2","page":"API","title":"Gabs.catstate","text":"catstate(basis::SymplecticBasis, α::Number, phase::Real=0; squeeze_params=nothing, ħ=2)\n\nCreate a general Schrödinger cat state |cat⟩ = (|α⟩ + e^(iφ)|-α⟩)/√N where φ is the relative phase.\n\nThis is the most general form of cat state, which reduces to even (φ=0) or odd (φ=π) cat states for specific phase values.\n\nArguments\n\nbasis::SymplecticBasis: The symplectic basis for the state\nα::Number: Complex amplitude of the coherent states\nphase::Real=0: Relative phase between the two coherent state components\nsqueeze_params=nothing: Optional tuple (r, θ) for squeezed cat states\nħ=2: Reduced Planck constant\n\nMathematical Description\n\n|cat⟩ = (|α⟩ + e^(iφ)|-α⟩)/√(2(1 + Re(e^(iφ)exp(-2|α|²))))\n\n\n\n\n\n","category":"function"},{"location":"API/#Gabs.catstate_even-Tuple{Gabs.SymplecticBasis, AbstractVector}","page":"API","title":"Gabs.catstate_even","text":"catstate_even(basis::SymplecticBasis, αs::AbstractVector; squeeze_params=nothing, ħ=2)\n\nCreate multi-mode even cat states as tensor products of single-mode cat states.\n\nArguments\n\nbasis::SymplecticBasis: The symplectic basis for the multi-mode system\nαs::AbstractVector: Vector of complex amplitudes for each mode\nsqueeze_params=nothing: Optional vector of tuples (r, θ) for each mode\nħ=2: Reduced Planck constant\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.catstate_even-Tuple{Gabs.SymplecticBasis, Number}","page":"API","title":"Gabs.catstate_even","text":"catstate_even(basis::SymplecticBasis, α::Number; squeeze_params=nothing, ħ=2)\n\nCreate an even Schrödinger cat state |cat+⟩ = (|α⟩ + |-α⟩)/√N where N is the normalization constant.\n\nThe even cat state is a quantum superposition of two coherent states (or squeezed states) with  opposite phases. The normalization accounts for the overlap between the two component states.\n\nArguments\n\nbasis::SymplecticBasis: The symplectic basis for the state\nα::Number: Complex amplitude of the coherent states\nsqueeze_params=nothing: Optional tuple (r, θ) for squeezed cat states where r is the squeeze parameter and θ is the squeeze angle\nħ=2: Reduced Planck constant\n\nMathematical Description:\n\nFor coherent states: |cat+⟩ = (|α⟩ + |-α⟩)/√(2(1 + exp(-2|α|²))) For squeezed states: The squeezed vacuum is first created, then displaced to ±α.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.catstate_odd-Tuple{Gabs.SymplecticBasis, AbstractVector}","page":"API","title":"Gabs.catstate_odd","text":"catstate_odd(basis::SymplecticBasis, αs::AbstractVector; squeeze_params=nothing, ħ=2)\n\nCreate multi-mode odd cat states as tensor products of single-mode cat states.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.catstate_odd-Tuple{Gabs.SymplecticBasis, Number}","page":"API","title":"Gabs.catstate_odd","text":"catstate_odd(basis::SymplecticBasis, α::Number; squeeze_params=nothing, ħ=2)\n\nCreate an odd Schrödinger cat state |cat-⟩ = (|α⟩ - |-α⟩)/√N where N is the normalization constant.\n\nThe odd cat state is a quantum superposition of two coherent states (or squeezed states) with  opposite phases and a relative minus sign.\n\nArguments\n\nbasis::SymplecticBasis: The symplectic basis for the state\nα::Number: Complex amplitude of the coherent states\nsqueeze_params=nothing: Optional tuple (r, θ) for squeezed cat states\nħ=2: Reduced Planck constant\n\nMathematical Description\n\nFor coherent states: |cat-⟩ = (|α⟩ - |-α⟩)/√(2(1 - exp(-2|α|²)))\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.changebasis-Union{Tuple{S}, Tuple{D}, Tuple{B2}, Tuple{B1}, Tuple{Type{B1}, GaussianChannel{B2, D, S}}} where {B1<:QuadBlockBasis, B2<:QuadPairBasis, D, S}","page":"API","title":"Gabs.changebasis","text":"changebasis(::SymplecticBasis, state::GaussianChannel)\n\nChange the symplectic basis of a Gaussian channel.\n\nExample\n\njulia> ch = attenuator(QuadBlockBasis(2), [1.0, 2.0], [2, 4])\nGaussianChannel for 2 modes.\n  symplectic basis: QuadBlockBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ntransform: 4×4 Matrix{Float64}:\n 0.540302   0.0       0.0        0.0\n 0.0       -0.416147  0.0        0.0\n 0.0        0.0       0.540302   0.0\n 0.0        0.0       0.0       -0.416147\nnoise: 4×4 Matrix{Float64}:\n 1.41615  0.0      0.0      0.0\n 0.0      3.30729  0.0      0.0\n 0.0      0.0      1.41615  0.0\n 0.0      0.0      0.0      3.30729\n\njulia> changebasis(QuadPairBasis, ch)\nGaussianChannel for 2 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ntransform: 4×4 Matrix{Float64}:\n 0.540302  0.0        0.0        0.0\n 0.0       0.540302   0.0        0.0\n 0.0       0.0       -0.416147   0.0\n 0.0       0.0        0.0       -0.416147\nnoise: 4×4 Matrix{Float64}:\n 1.41615  0.0      0.0      0.0\n 0.0      1.41615  0.0      0.0\n 0.0      0.0      3.30729  0.0\n 0.0      0.0      0.0      3.30729\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.changebasis-Union{Tuple{S}, Tuple{D}, Tuple{B2}, Tuple{B1}, Tuple{Type{B1}, GaussianUnitary{B2, D, S}}} where {B1<:QuadBlockBasis, B2<:QuadPairBasis, D, S}","page":"API","title":"Gabs.changebasis","text":"changebasis(::SymplecticBasis, state::GaussianUnitary)\n\nChange the symplectic basis of a Gaussian unitary.\n\nExample\n\njulia> op = displace(QuadBlockBasis(2), 1.0-im)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadBlockBasis\ndisplacement: 4-element Vector{Float64}:\n  2.0\n  2.0\n -2.0\n -2.0\nsymplectic: 4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> changebasis(QuadPairBasis, op)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 4-element Vector{Float64}:\n  2.0\n -2.0\n  2.0\n -2.0\nsymplectic: 4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.changebasis-Union{Tuple{V}, Tuple{M}, Tuple{B2}, Tuple{B1}, Tuple{Type{B1}, GaussianState{B2, M, V}}} where {B1<:QuadBlockBasis, B2<:QuadPairBasis, M, V}","page":"API","title":"Gabs.changebasis","text":"changebasis(::SymplecticBasis, state::GaussianState)\n\nChange the symplectic basis of a Gaussian state.\n\nExample\n\njulia> st = squeezedstate(QuadBlockBasis(2), 1.0, 2.0)\nGaussianState for 2 modes.\n  symplectic basis: QuadBlockBasis\nmean: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n  5.2715    0.0      -3.29789   0.0\n  0.0       5.2715    0.0      -3.29789\n -3.29789   0.0       2.25289   0.0\n  0.0      -3.29789   0.0       2.25289\n\njulia> changebasis(QuadPairBasis, st)\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n  5.2715   -3.29789   0.0       0.0\n -3.29789   2.25289   0.0       0.0\n  0.0       0.0       5.2715   -3.29789\n  0.0       0.0      -3.29789   2.25289\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.coherentstate-Union{Tuple{A}, Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}, A}} where {Tm, Tc, N<:Int64, A}","page":"API","title":"Gabs.coherentstate","text":"coherentstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, alpha<:Number)\n\nGaussian state that is the quantum analogue of a monochromatic electromagnetic field, known as the coherent state. The symplectic representation is defined by basis. The complex amplitude of the state is given by alpha.\n\nMathematical description of a coherent state\n\nA coherent state |α⟩, where α is the complex amplitude, is characterized by the mean vector √2ħ [real(α), imag(α)] and covariance matrix (ħ/2)I.\n\nExample\n\njulia> coherentstate(QuadPairBasis(1), 1.0+im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 2.0\n 2.0\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.cross_wigner-Tuple{GaussianState, GaussianState, AbstractVector}","page":"API","title":"Gabs.cross_wigner","text":"cross_wigner(state1::GaussianState, state2::GaussianState, x::AbstractVector)\n\nCompute the off-diagonal Wigner kernel (cross-Wigner function) between two Gaussian states.\n\nThe cross-Wigner function is given by:\n\n`W₁₂(x) = (1/(2π)ⁿ√det((V₁+V₂)/2)) × exp[-½(x-μ̄)ᵀ((V₁+V₂)/2)⁻¹(x-μ̄)] × exp[i(μ₁-μ₂)ᵀΩ(x-μ̄)/ħ]`\n\nwhere:\n\nμ̄ = (μ₁ + μ₂)/2 is the average of the two mean vectors\nμ₁, μ₂ are the mean vectors of the two states  \nV₁, V₂ are the covariance matrices of the two states\nΩ is the symplectic form matrix\nn is the number of modes\nħ is the reduced Planck constant\n\nThis function captures the quantum interference between two Gaussian states and is  essential for computing Wigner functions of superposition states. The cross-Wigner  function appears in the interference terms when computing the Wigner function of  a linear combination |ψ⟩ = c₁|ψ₁⟩ + c₂|ψ₂⟩:\n\n`W(x) = |c₁|²W₁(x) + |c₂|²W₂(x) + 2Re(c₁*c₂*W₁₂(x))`\n\nThe normalization is chosen to ensure the identity property W₁₁(x) = W₁(x).\n\nArguments\n\nstate1::GaussianState: First Gaussian state\nstate2::GaussianState: Second Gaussian state  \nx::AbstractVector: Phase space point where to evaluate the function\n\nReturns\n\nComplexF64: Complex value of the cross-Wigner function at point x\n\nNotes\n\nThe function is Hermitian: W₁₂(x) = W₂₁*(x)\nFor identical states: W₁₁(x) = W₁(x) (reduces to regular Wigner function)\nThe implementation uses log-space arithmetic for numerical stability\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.cross_wignerchar-Tuple{GaussianState, GaussianState, AbstractVector}","page":"API","title":"Gabs.cross_wignerchar","text":"cross_wignerchar(state1::GaussianState, state2::GaussianState, xi::AbstractVector)\n\nCompute cross-Wigner characteristic function between two Gaussian states.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.displace-Union{Tuple{A}, Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}, A}} where {Td, Ts, N<:Int64, A}","page":"API","title":"Gabs.displace","text":"displace([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, alpha<:Number)\ndisplace([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, alpha<:Number, noise::Ts)\n\nGaussian operator that displaces the vacuum state into a coherent state, known as the displacement operator. The symplectic representation is given by basis. The complex amplitude is given by alpha. Noise can be added to the operation with noise.\n\nMathematical description of a displacement operator\n\nA displacement operator D(α) is defined by the operation D(α)|0⟩ = |α⟩, where α is a complex amplitude. The operator D(α)  is characterized by the displacement vector √2ħ [real(α), imag(α)]  and symplectic matrix I.\n\nExample\n\njulia> displace(QuadPairBasis(1), 1.0+im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 2.0\n 2.0\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.eprstate-Union{Tuple{R}, Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}, R, R}} where {Tm, Tc, N<:Int64, R}","page":"API","title":"Gabs.eprstate","text":"eprstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, r<:Real, theta<:Real)\n\nGaussian state that is a two-mode squeezed state, known as the Einstein-Podolski-Rosen (EPR) state. The symplectic representation is defined by basis. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of an EPR state\n\nAn EPR state |r, θ⟩ₑₚᵣ, where r is the amplitude squeezing parameter and θ is the phase squeezing parameter, is characterized by the zero mean vector and covariance matrix (ħ/2)[cosh(2r)I -sinh(2r)R(θ); -sinh(2r)R(θ) cosh(2r)I],  where R(θ) is the rotation matrix.\n\nExample\n\njulia> eprstate(QuadPairBasis(2), 0.5, pi/4)\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n  1.54308    0.0       -0.830993  -0.830993\n  0.0        1.54308   -0.830993   0.830993\n -0.830993  -0.830993   1.54308    0.0\n -0.830993   0.830993   0.0        1.54308\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.generaldyne-Union{Tuple{S}, Tuple{R}, Tuple{Tc}, Tuple{Tm}, Tuple{GaussianState{<:QuadPairBasis, Tm, Tc}, R}} where {Tm, Tc, R, S<:Union{GaussianState, Matrix}}","page":"API","title":"Gabs.generaldyne","text":"generaldyne(state::GaussianState, indices::Vector; proj = (ħ/2)I) -> Generaldyne\ngeneraldyne(state::GaussianState, index::Int; proj = (ħ/2)I) -> Generaldyne\n\nCompute the projection of the subsystem of a Gaussian state state indicated by indices on proj and return a Generaldyne object. The keyword argument proj can take the following forms:\n\nIf proj is a matrix, then the subsystem is projected onto a Gaussian state with a randomly sampled mean and covariance matrix result.\nIf proj is a Gaussian state, then the subsystem is projected onto proj.\n\nThe result and mapped state output can be obtained from the Generaldyne object M via M.result and M.output. Iterating the decomposition produces the components result and output.\n\nNote the measured modes are replaced with vacuum states after the general-dyne measurement.\n\nExamples\n\njulia> st = squeezedstate(QuadBlockBasis(3), 1.0, pi/4);\n\njulia> M = generaldyne(st, [1, 3])\nGeneraldyne{GaussianState{QuadBlockBasis{Int64}, Vector{Float64}, Matrix{Float64}}, GaussianState{QuadBlockBasis{Int64}, Vector{Float64}, Matrix{Float64}}}\nresult:\nGaussianState for 2 modes.\n  symplectic basis: QuadBlockBasis\nmean: 4-element Vector{Float64}:\n  0.26967410461090285\n  1.4683993027500133\n -1.84631450059537\n  0.16832788926417352\ncovariance: 4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\noutput state:\nGaussianState for 3 modes.\n  symplectic basis: QuadBlockBasis\nmean: 6-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 6×6 Matrix{Float64}:\n 1.0   0.0      0.0  0.0   0.0      0.0\n 0.0   1.19762  0.0  0.0  -2.56458  0.0\n 0.0   0.0      1.0  0.0   0.0      0.0\n 0.0   0.0      0.0  1.0   0.0      0.0\n 0.0  -2.56458  0.0  0.0   6.32677  0.0\n 0.0   0.0      0.0  0.0   0.0      1.0\n\njulia> result, state = M; # destructuring via iteration\n\njulia> result == M.result && state == M.state\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.gkpstate-Tuple{Gabs.SymplecticBasis}","page":"API","title":"Gabs.gkpstate","text":"gkpstate(basis::SymplecticBasis; lattice=:square, delta=0.1, nmax=5, ħ=2)\n\nCreate a Gottesman-Kitaev-Preskill (GKP) state as a finite-energy approximation using squeezed states.\n\nGKP states are quantum error-correcting codes that protect against small displacement errors. They are constructed as superpositions of squeezed states positioned at lattice points in phase space.\n\nArguments\n\nbasis::SymplecticBasis: The symplectic basis for the state\nlattice=:square: Lattice type (:square or :hexagonal)\ndelta=0.1: Squeezing parameter for finite energy approximation (smaller = more squeezed)\nnmax=5: Maximum lattice index for truncation (controls number of peaks)\nħ=2: Reduced Planck constant\n\nNotes\n\nVery small delta values (< 1e-6) may cause numerical instability\nLarge nmax values (> 50) create many states and may impact performance\nFor square lattice: creates 2*nmax + 1 total states\n\nMathematical Description\n\nFor square lattice: |GKP⟩ = Σₖ |xₖ⟩ where xₖ = √(2πħ) × k for integer k ∈ [-nmax, nmax] Each |xₖ⟩ is approximated by a squeezed state with squeezing delta in the conjugate direction.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.isgaussian-Union{Tuple{GaussianState}, Tuple{R2}, Tuple{R1}} where {R1<:Real, R2<:Real}","page":"API","title":"Gabs.isgaussian","text":"isgaussian(x::GaussianState)\nisgaussian(x::GaussianUnitary)\nisgaussian(x::GaussianChannel)\n\nCheck if x satisfies the corresponding Gaussian definition for its type.\n\nExample\n\njulia> basis = QuadPairBasis(1);\n\njulia> op = displace(basis, 1.0-im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n  2.0\n -2.0\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\njulia> isgaussian(op)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.norm_factor-Tuple{Vector{<:GaussianState}, Vector{<:Number}}","page":"API","title":"Gabs.norm_factor","text":"norm_factor(states::Vector{GaussianState}, coeffs::Vector{<:Number})\n\nCalculate the normalization factor for a linear combination of Gaussian states.\n\nThis function computes the normalization constant needed to ensure ⟨ψ|ψ⟩ = 1 for a state |ψ⟩ = Σᵢ cᵢ|ψᵢ⟩ by calculating all overlap integrals between component states.\n\nArguments\n\nstates::Vector{GaussianState}: Vector of Gaussian states\ncoeffs::Vector{<:Number}: Vector of coefficients\n\nReturns\n\nFloat64: Normalization factor N such that the state Σᵢ (cᵢ/N)|ψᵢ⟩ is normalized\n\nNotes\n\nReturns 1.0 if near-zero or negative normalization is detected (may indicate coefficient cancellation)\nNumerical instabilities can occur with very small coefficients or nearly orthogonal states\n\nMathematical Description\n\nN² = Σᵢⱼ cᵢ* cⱼ ⟨ψᵢ|ψⱼ⟩\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.phaseshift-Union{Tuple{R}, Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}, R}} where {Td, Ts, N<:Int64, R}","page":"API","title":"Gabs.phaseshift","text":"phaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, theta<:Real)\nphaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, theta<:Real, noise::Ts)\n\nGaussian operator that rotates the phase of a given Gaussian mode by theta, as the phase shift operator. The symplectic representation is given by basis. Noise can be added to the operation with noise.\n\nMathematical description of a phase shift operator\n\nA phase shift operator is defined by the operation U(θ) = exp(-iθâᵗâ), where θ is the phase parameter, and âᵗ and â are the raising and lowering operators, respectively. The operator U(θ) is characterized by  the zero displacement vector and symplectic matrix [cos(θ) sin(θ); -sin(θ) cos(θ)].\n\nExample\n\njulia> phaseshift(QuadPairBasis(1), 3pi/4)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n -0.707107   0.707107\n -0.707107  -0.707107\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.purity-Tuple{GaussianState}","page":"API","title":"Gabs.purity","text":"purity(state::GaussianState)\n\nCalculate the purity of a Gaussian state, defined by 1/sqrt((2/ħ) det(V)).\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.randchannel-Union{Tuple{N}, Tuple{Tt}, Tuple{Td}, Tuple{Type{Td}, Type{Tt}, Gabs.SymplecticBasis{N}}} where {Td, Tt, N<:Int64}","page":"API","title":"Gabs.randchannel","text":"randchannel([Td=Vector{Float64}, Tt=Matrix{Float64},] basis::SymplecticBasis)\n\nCalculate a random Gaussian channel in symplectic representation defined by basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.randstate-Union{Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}}} where {Tm, Tc, N<:Int64}","page":"API","title":"Gabs.randstate","text":"randstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis; pure=false)\n\nCalculate a random Gaussian state in symplectic representation defined by basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.randunitary-Union{Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}}} where {Td, Ts, N<:Int64}","page":"API","title":"Gabs.randunitary","text":"randunitary([Td=Vector{Float64}, Ts=Matrix{Float64},] basis::SymplecticBasis; passive=false)\n\nCalculate a random Gaussian unitary operator in symplectic representation defined by basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.squeeze-Union{Tuple{R}, Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}, R, R}} where {Td, Ts, N<:Int64, R}","page":"API","title":"Gabs.squeeze","text":"squeeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real)\nsqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes the vacuum state into a squeezed state, known as the squeezing operator. The symplectic representation is given by basis. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a squeezing operator\n\nA squeeze operator S(r, θ) is defined by the operation S(r, θ)|0⟩ = |r, θ⟩, where r and θ are the real amplitude and phase parameters,  respectively. The operator S(r, θ) is characterized by  the zero displacement vector and symplectic matrix cosh(r)I - sinh(r)R(θ), where R(θ) is the rotation matrix.\n\nExample\n\njulia> squeeze(QuadPairBasis(1), 0.25, pi/4)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n  0.852789  -0.178624\n -0.178624   1.21004\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.squeezedstate-Union{Tuple{R}, Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}, R, R}} where {Tm, Tc, N<:Int64, R}","page":"API","title":"Gabs.squeezedstate","text":"squeezedstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, r<:Real, theta<:Real)\n\nGaussian state with quantum uncertainty in its phase and amplitude, known as the squeezed state. The symplectic representation is defined by basis. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of a squeezed state\n\nA squeezed state |r, θ⟩, where r is the amplitude squeezing parameter and θ is the phase squeezing parameter, is characterized by the zero mean vector and covariance matrix (ħ/2) (cosh(2r)I - sinh(2r)R(θ)), where R(θ) is the rotation matrix.\n\nExample\n\njulia> squeezedstate(QuadPairBasis(1), 0.5, pi/4)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n  0.712088  -0.830993\n -0.830993   2.37407\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.sympspectrum-Tuple{GaussianState}","page":"API","title":"Gabs.sympspectrum","text":"sympspectrum(state::GaussianState)\n\nCompute the symplectic spectrum of a Gaussian state.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.thermalstate-Union{Tuple{P}, Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}, P}} where {Tm, Tc, N<:Int64, P}","page":"API","title":"Gabs.thermalstate","text":"thermalstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, photons<:Int)\n\nGaussian state at thermal equilibrium, known as the thermal state. The symplectic representation is defined by basis. The mean photon number of the state is given by photons.\n\nMathematical description of a thermal state\n\nA thermal state |n̄⟩, where n̄ is the mean number of photons, is characterized by the zero mean vector and covariance matrix ħ(n̄+1/2)I.\n\nExample\n\njulia> thermalstate(QuadPairBasis(1), 4)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 9.0  0.0\n 0.0  9.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.twosqueeze-Union{Tuple{R}, Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}, R, R}} where {Td, Ts, N<:Int64, R}","page":"API","title":"Gabs.twosqueeze","text":"twosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real)\ntwosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes a two-mode vacuum state into a two-mode squeezed state, known as the two-mode squeezing operator. The symplectic representation is given by basis. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a two-mode squeezing operator\n\nA two-mode squeeze operator S₂(r, θ) is defined by the operation S₂(r, θ)|0⟩ = |r, θ⟩, where r and θ are the real amplitude and phase parameters, respectively. The operator  S₂(r, θ) is characterized by the zero displacement vector and symplectic matrix [cosh(r)I -sinh(r)R(θ); -sinh(r)R(θ) cosh(r)I], where R(θ) is the rotation matrix.\n\nExample\n\njulia> twosqueeze(QuadPairBasis(2), 0.25, pi/4)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  1.03141    0.0       -0.178624  -0.178624\n  0.0        1.03141   -0.178624   0.178624\n -0.178624  -0.178624   1.03141    0.0\n -0.178624   0.178624   0.0        1.03141\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.vacuumstate-Union{Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}}} where {Tm, Tc, N<:Int64}","page":"API","title":"Gabs.vacuumstate","text":"vacuumstate([Tm=Vector{Float64}, Tc=Matrix{Float64}], basis::SymplecticBasis)\n\nGaussian state with zero photons, known as the vacuum state. The symplectic representation is defined by basis.\n\nMathematical description of a vacuum state\n\nA vacuum state |0⟩ is characterized by the zero mean vector and covariance matrix (ħ/2)I.\n\nExample\n\njulia> vacuumstate(QuadPairBasis(1))\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.wigner-Tuple{GaussianLinearCombination, AbstractVector}","page":"API","title":"Gabs.wigner","text":"wigner(lc::GaussianLinearCombination, x::AbstractVector)\n\nCompute Wigner function of a linear combination including quantum interference. W(x) = Σᵢ |cᵢ|² Wᵢ(x) + 2 Σᵢ<ⱼ Re(cᵢ*cⱼ W_cross(ψᵢ,ψⱼ,x))\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.wigner-Union{Tuple{T}, Tuple{GaussianState, T}} where T","page":"API","title":"Gabs.wigner","text":"wigner(state::GaussianState, x)\n\nCompute the Wigner function of an N-mode Gaussian state at x, a vector of size 2N.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.wignerchar-Tuple{GaussianLinearCombination, AbstractVector}","page":"API","title":"Gabs.wignerchar","text":"wignerchar(lc::GaussianLinearCombination, xi::AbstractVector)\n\nCompute Wigner characteristic function of a linear combination including interference.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.wignerchar-Union{Tuple{T}, Tuple{GaussianState, T}} where T","page":"API","title":"Gabs.wignerchar","text":"wignerchar(state::GaussianState, xi)\n\nCompute the Wigner characteristic function of an N-mode Gaussian state at xi, a vector of size 2N.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.apply!-Tuple{GaussianState, GaussianChannel}","page":"API","title":"QuantumInterface.apply!","text":"apply!(state::GaussianState, op::GaussianChannel)\n\nIn-place application of a Gaussian channel op on a Gaussian state state.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.apply!-Tuple{GaussianState, GaussianUnitary}","page":"API","title":"QuantumInterface.apply!","text":"apply!(state::GaussianState, op::GaussianUnitary)\n\nIn-place application of a Gaussian unitary op on a Gaussian state state.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.directsum-Union{Tuple{R}, Tuple{R, R}} where R<:Gabs.SymplecticBasis","page":"API","title":"QuantumInterface.directsum","text":"directsum(basis1::SymplecticBasis, basis2::SymplecticBasis)\n\nCompute the direct sum of symplectic bases.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.entropy_vn-Union{Tuple{GaussianState{B, M, V}}, Tuple{V}, Tuple{M}, Tuple{B}} where {B, M, V}","page":"API","title":"QuantumInterface.entropy_vn","text":"entropy_vn(state::GaussianState; tol::Real = 128 * eps(1/2))\n\nCalculate the Von Neumann entropy of a Gaussian state, defined as\n\nS(rho) = -Tr(rho log(rho)) = sum_i f(v_i)\n\nsuch that log denotes the natural logarithm, v_i is the symplectic spectrum of mathbfVhbar, and the f is taken to be\n\nf(x) = (x + 12) log(x + 12) - (x - 12) log(x - 12)\n\nwherein it is understood that 0 log(0) equiv 0.\n\nArguments\n\nstate: Gaussian state whose Von Neumann entropy is to be calculated.\ntol: Tolerance (exclusive) above the cut-off at 12 for computing f(x).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.fidelity-Union{Tuple{V2}, Tuple{M2}, Tuple{B2}, Tuple{V1}, Tuple{M1}, Tuple{B1}, Tuple{GaussianState{B1, M1, V1}, GaussianState{B2, M2, V2}}} where {B1, M1, V1, B2, M2, V2}","page":"API","title":"QuantumInterface.fidelity","text":"fidelity(state1::GaussianState, state2::GaussianState; tol::Real = 128 * eps(1))\n\nCalculate the joint fidelity of two Gaussian states, defined as\n\nF(rho sigma) = Tr(sqrtsqrtrho sigma sqrtrho)\n\nSee: Banchi, Braunstein, and Pirandola, Phys. Rev. Lett. 115, 260501 (2015)\n\nArguments\n\nstate1, state2: Gaussian states whose joint fidelity is to be calculated.\ntol: Tolerance (inclusive) above the cut-off at 1 for computing x + sqrtx^2 - 1.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.logarithmic_negativity-Union{Tuple{V}, Tuple{M}, Tuple{B}, Tuple{GaussianState{B, M, V}, Union{Integer, AbstractVector{<:Integer}}}} where {B, M, V}","page":"API","title":"QuantumInterface.logarithmic_negativity","text":"logarithmic_negativity(state::GaussianState, indices::Union{Integer, AbstractVector{<:Integer}}; tola::Real = 0, tolb::Real = 128 * eps(1))\n\nCalculate the logarithmic negativity of a Gaussian state partition, defined as\n\nN(rho) = logrho^T_B_1 = - sum_i log(2 tildev_i^)\n\nsuch that log denotes the natural logarithm, tildev_i^ is the symplectic spectrum of mathbftildeVhbar which is  12.\n\nTherein, mathbftildeV = mathbfT mathbfV mathbfT where\n\nforall k  mathbfT q_k = q_k\nforall k in mathrmB  mathbfT p_k = -p_k\nforall k notin mathrmB  mathbfT p_k = p_k\n\nArguments\n\nstate: Gaussian state whose logarithmic negativity is to be calculated.\nindices: Integer or collection thereof, specifying the binary partition.\ntola: Tolerance (inclusive) above the cut-off at 0 for computing log(x).\ntolb: Tolerance (inclusive) below the cut-off at 1 for computing log(x).\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.ptrace-Tuple{GaussianLinearCombination, AbstractVector{<:Int64}}","page":"API","title":"QuantumInterface.ptrace","text":"ptrace(lc::GaussianLinearCombination, indices::AbstractVector{<:Int})\n\nCompute partial trace of a linear combination over specified indices. Combines identical traced states automatically.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.ptrace-Tuple{GaussianLinearCombination, Int64}","page":"API","title":"QuantumInterface.ptrace","text":"ptrace(lc::GaussianLinearCombination, index::Int)\n\nCompute partial trace of a linear combination over specified index.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.ptrace-Union{Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, GaussianState, N}} where {Tm, Tc, N}","page":"API","title":"QuantumInterface.ptrace","text":"ptrace([Tm=Vector{Float64}, Tc=Matrix{Float64},] state::GaussianState, idx<:Int)\nptrace([Tm=Vector{Float64}, Tc=Matrix{Float64},] state::GaussianState, indices<:AbstractVector)\n\nPartial trace of a Gaussian state over a subsystem indicated by idx, or multiple subsystems indicated by indices.\n\nExample\n\njulia> basis = QuadPairBasis(1);\n\njulia> state = coherentstate(basis, 1.0+im) ⊗ thermalstate(basis, 2) ⊗ squeezedstate(basis, 3.0, pi/4);\n\njulia> ptrace(state, 2)\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element Vector{Float64}:\n 2.0\n 2.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n 1.0  0.0     0.0        0.0\n 0.0  1.0     0.0        0.0\n 0.0  0.0    59.0829  -142.633\n 0.0  0.0  -142.633    344.348\n\njulia> ptrace(state, [1, 3])\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 5.0  0.0\n 0.0  5.0\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Tuple{GaussianLinearCombination, GaussianLinearCombination}","page":"API","title":"QuantumInterface.tensor","text":"tensor(lc1::GaussianLinearCombination, lc2::GaussianLinearCombination)\n\nCompute tensor product of two linear combinations of Gaussian states.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Union{Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, GaussianLinearCombination, GaussianLinearCombination}} where {Tm, Tc}","page":"API","title":"QuantumInterface.tensor","text":"tensor(::Type{Tc}, ::Type{Ts}, lc1::GaussianLinearCombination, lc2::GaussianLinearCombination)\n\nCompute tensor product of two linear combinations with specified output types. Creates all pairwise tensor products: Σᵢⱼ cᵢcⱼ |ψᵢ⟩ ⊗ |ϕⱼ⟩.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Union{Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, GaussianState, GaussianState}} where {Tm, Tc}","page":"API","title":"QuantumInterface.tensor","text":"tensor(state1::GaussianState, state2::GaussianState)\n\ntensor product of Gaussian states, which can also be called with ⊗.\n\nExample\n\njulia> basis = QuadPairBasis(1);\n\njulia> coherentstate(basis, 1.0+im) ⊗ thermalstate(basis, 2)\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element Vector{Float64}:\n 2.0\n 2.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  5.0  0.0\n 0.0  0.0  0.0  5.0\n\n\n\n\n\n","category":"method"},{"location":"API/#SymplecticFactorizations.blochmessiah-Union{Tuple{GaussianUnitary{<:QuadBlockBasis, D, S}}, Tuple{S}, Tuple{D}} where {D, S}","page":"API","title":"SymplecticFactorizations.blochmessiah","text":"blochmessiah(state::GaussianUnitary) -> BlochMessiah\n\nCompute the Bloch-Messiah/Euler decomposition of the symplectic field of a GaussianUnitary and return a BlockMessiah object.\n\nThe orthogonal symplectic matrices O and Q as well as the singular values values can be obtained via F.O, F.Q, and F.values, respectively.\n\nIterating the decomposition produces the components O, values, and Q, in that order.\n\n\n\n\n\n","category":"method"},{"location":"API/#SymplecticFactorizations.issymplectic-Union{Tuple{R2}, Tuple{R1}, Tuple{T}, Tuple{Gabs.SymplecticBasis, T}} where {T, R1<:Real, R2<:Real}","page":"API","title":"SymplecticFactorizations.issymplectic","text":"issymplectic(basis::SymplecticBasis, x::T)\n\nCheck if input matrix satisfies symplectic definition.\n\nExample\n\njulia> basis = QuadPairBasis(1);\n\njulia> issymplectic(basis, [1.0 0.0; 0.0 1.0])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#SymplecticFactorizations.polar-Union{Tuple{GaussianUnitary{B, D, S}}, Tuple{S}, Tuple{D}, Tuple{B}} where {B<:Gabs.SymplecticBasis, D, S}","page":"API","title":"SymplecticFactorizations.polar","text":"polar(state::GaussianUnitary) -> Polar\n\nCompute the Polar decomposition of the symplectic field of a GaussianUnitary object and return a Polar object.\n\nO and P can be obtained from the factorization F via F.O and F.P, such that S = O * P. For the symplectic polar decomposition case, O is an orthogonal symplectic matrix and P is a positive-definite symmetric symplectic matrix.\n\nIterating the decomposition produces the components O and P.\n\n\n\n\n\n","category":"method"},{"location":"API/#SymplecticFactorizations.randsymplectic-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Gabs.SymplecticBasis{N}}} where {T, N<:Int64}","page":"API","title":"SymplecticFactorizations.randsymplectic","text":"randsymplectic([T=Matrix{Float64},] basis::SymplecticBasis, passive=false)\n\nCalculate a random symplectic matrix in symplectic representation defined by basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#SymplecticFactorizations.symplecticform-Union{Tuple{QuadPairBasis{N}}, Tuple{N}} where N<:Int64","page":"API","title":"SymplecticFactorizations.symplecticform","text":"symplecticform([T = Matrix{Float64},] basis::SymplecticBasis)\n\nCompute the symplectic form matrix of size 2N x 2N corresponding to basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#SymplecticFactorizations.williamson-Union{Tuple{GaussianState{<:QuadBlockBasis, M, V}}, Tuple{V}, Tuple{M}} where {M, V}","page":"API","title":"SymplecticFactorizations.williamson","text":"williamson(state::GaussianState) -> Williamson\n\nCompute the williamson decomposition of the covar field of a GaussianState object and return a Williamson object.\n\nA symplectic matrix S and symplectic spectrum spectrum can be obtained via F.S and F.spectrum.\n\nIterating the decomposition produces the components S and spectrum.\n\nTo compute only the symplectic spectrum of a Gaussian state, call sympspectrum.\n\n\n\n\n\n","category":"method"}]
}
