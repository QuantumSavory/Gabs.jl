var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"DocTestSetup = quote\n    using Gabs\nend","category":"page"},{"location":"tutorials/#Visualizations","page":"Tutorials","title":"Visualizations","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Quasiprobability distributions of Gaussian states can be visualized with Makie.jl. Gabs.jl currently has support for the following distributions, which can be called with the keyword argument dist:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"wigner\nwignerchar","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Below is a code example that plots the wigner distribution of a vacuum state:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Gabs, CairoMakie\nbasis = QuadPairBasis(1)\nstate = vacuumstate(basis)\nq, p = collect(-5.0:0.5:5.0), collect(-5.0:0.5:5.0) # phase space coordinates\nheatmap(q, p, state, dist = :wigner)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Of course, more plotting sugar can be added to this example with internal Makie attributes:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Gabs, CairoMakie\nbasis = QuadPairBasis(1)\nstate = vacuumstate(basis)\nq, p = collect(-5.0:0.5:5.0), collect(-5.0:0.5:5.0) # phase space coordinates\nfig = Figure(fontsize=15, size = (375, 300), fonts = (; regular=\"CMU Serif\"))\nax = Axis(fig[1,1], xlabel = L\"q\", ylabel = L\"p\")\nhm = heatmap!(ax, q, p, state, dist = :wigner, colormap = :heat)\nColorbar(fig[1,2], hm)\nfig","category":"page"},{"location":"tutorials/#Using-Custom-Arrays","page":"Tutorials","title":"Using Custom Arrays","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Types such as GaussianState, GaussianUnitary, and GaussianChannel are agnostic array wrappers, so they can hold any custom array that exists in the Julia ecosystem. Operations in Gabs.jl preserve these custom array types, provided they follow the AbstractArray interface.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let's explore this feature in detail, using StaticArrays.jl and SparseArrays.jl as a case study. To create a coherent state that wraps around pure Julia arrays, the function coherentstate can be called with a single complex argument:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"julia> coherentstate(QuadPairBasis(1), 1.0-im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n  1.4142135623730951\n -1.4142135623730951\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Here, a GaussianState object containing a Vector{Float64} of size two (mean vector) and a Matrix{Float64} of size two by two (covariance matrix) was initialized. If we want to potentially optimize and boost the performance of our code, then one approach would be to wrap our GaussianState around different array types, for instance, an SVector from StaticArrays.jl or a SparseVector from SparseArrays.jl. Any defined method in Gabs.jl that (i) creates a custom type or (ii) transforms a custom type can specify an array type in its first (and second) arguments. Let's see an example with StaticArrays.jl:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"julia> using StaticArrays\n\njulia> state = coherentstate(SVector{2}, SMatrix{2,2}, QuadPairBasis(1), 1.0-im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element SVector{2, Float64} with indices SOneTo(2):\n  1.4142135623730951\n -1.4142135623730951\ncovariance: 2×2 SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):\n 1.0  0.0\n 0.0  1.0\n\njulia> tp = state ⊗ state\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element SVector{4, Float64} with indices SOneTo(4):\n  1.4142135623730951\n -1.4142135623730951\n  1.4142135623730951\n -1.4142135623730951\ncovariance: 4×4 SMatrix{4, 4, Float64, 16} with indices SOneTo(4)×SOneTo(4):\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> using SparseArrays\n\njulia> ptrace(SparseVector, SparseMatrixCSC, tp, 1)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element SparseVector{Float64, Int64} with 2 stored entries:\n  [1]  =  1.41421\n  [2]  =  -1.41421\ncovariance: 2×2 SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n 1.0   ⋅ \n  ⋅   1.0","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Importantly, methods that create or manipulate a Gaussian state, such as tensor and ptrace, preserve array types, but can also opt for a different array type.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"note: Note\nIf you have an array wrapper that initializes both vectors and matrices, then you can specify the array type with a single argument. For instance, to initialize a state that contains Arrays holding numbers of type Float32 rather than Float64, simply pass Array{Float32} to any relevant Gabs.jl method:julia> state = displace(Array{Float32}, QuadPairBasis(1), 1.0-im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float32}:\n  1.4142135\n -1.4142135\nsymplectic: 2×2 Matrix{Float32}:\n 1.0  0.0\n 0.0  1.0","category":"page"},{"location":"tutorials/#GPU-Acceleration","page":"Tutorials","title":"GPU Acceleration","text":"","category":"section"},{"location":"tutorials/#Multithreading","page":"Tutorials","title":"Multithreading","text":"","category":"section"},{"location":"tutorials/#Benchmarking-and-Profiling","page":"Tutorials","title":"Benchmarking and Profiling","text":"","category":"section"},{"location":"intro/#intro","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"Gabs is a numerical tooling package for simulating Gaussian quantum information. Gaussian states and operators have the convenient property that they can be characterized by low-dimensional matrices in the phase space representation. Thus, a large class of continuous variable quantum information can be efficiently simulated on a classical computer. Gabs provides a high-level Julia interface for performing such efficient simulations in a straightforward manner.","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"In the sections below, a getting started tutorial is provided to introduce the capabilities of Gabs. The rest of the documentation is structured as follows:","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"Manual - an overview of the package types and inner-workings,\nTutorials - explanations for using particular features of the library,\nGaussian Zoos - a description of predefined Gaussian states and operators,\nAPI - the full API of the library,\nSuggested Readings and References - publications and learning resources on Gaussian quantum information.","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"note: Note\nThis documentation assumes familiarity with linear algebra and quantum information. Introductory books and tutorials for these topics are provided in the Suggested Readings and References page.","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"tip: Contributing\nAny contribution to Gabs is welcome! Feature suggestions, pull requests, and bug reports can be submitted on Github. The maintainers of Gabs subscribe to the Julia Community Standards.","category":"page"},{"location":"intro/#Installation","page":"Getting Started with Gabs","title":"Installation","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"To install Gabs.jl, start Julia and run the following command:","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"using Pkg\nPkg.add(\"Gabs\")","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"To use the package, run the command","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"using Gabs","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"Now, the entire library is loaded into the current workspace, with access to its high-level interface and predefined objects.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"DocTestSetup = quote\n    using Gabs\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Simply put, Gabs is a package for creating and transforming Gaussian bosonic systems. This section discusses the \"lower level\" tools for simulating such phenomena, with mathematical explanations when appropriate. For comprehensive reviews of Gaussian quantum information, see the suggested readings page.","category":"page"},{"location":"manual/#The-Symplectic-Formalism","page":"Manual","title":"The Symplectic Formalism","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The underlying geometry of Gaussian informatics in the phase space is symplectic. From the basic canonical commutation relations (CCRs) of quantized continuous variable systems, manifestations of the symplectic group textSp(2N mathbbR) appear everywhere. In Gabs, symplectic basis types must be defined from the beginning. Here's how they are laid out in this library:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"canonical ordering symplectic form basis type\n(hatx_1 hatp_1 cdots hatx_N hatp_N) beginpmatrix 0  1  - 1  0 endpmatrix otimes mathbfI_N QuadPairBasis\n(hatx_1 cdots hatx_N hatp_1 cdots hatp_N) beginpmatrix 0  mathbfI_N  -mathbfI_N  0 endpmatrix QuadBlockBasis","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Each symplectic basis type is wrapped around the number of bosonic modes N. We can compose a larger symplectic basis with directsum or ⊕, the direct sum symbol which can be typed in the Julia REPL as \\oplus<TAB>:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> b = QuadPairBasis(2)\nQuadPairBasis(2)\n\njulia> b ⊕ b\nQuadPairBasis(4)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Of course, this type of behavior will occur implicitly when we take tensor products of Gaussian states and operators, as discussed in the following sections.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nA matrix mathbfS of size 2Ntimes 2N is symplectic when it satisfies the relation mathbfS mathbfOmega mathbfS^textT = mathbfOmega where mathbfOmega is an invertible skew-symmetric matrix known as the symplectic form.","category":"page"},{"location":"manual/#Gaussian-States","page":"Manual","title":"Gaussian States","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The star of this package is the GaussianState type, which allows us to initialize and manipulate a phase space description of an arbitrary Gaussian state.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"GaussianState","category":"page"},{"location":"manual/#Gabs.GaussianState-manual","page":"Manual","title":"Gabs.GaussianState","text":"Defines a Gaussian state for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic basis for Gaussian state.\nmean: The mean vector of length 2N.\ncovar: The covariance matrix of size 2N x 2N.\n\nMathematical description of a Gaussian state\n\nAn N-mode Gaussian state, hatrho(mathbfbarx mathbfV), is a density operator characterized by two statistical moments: a mean vector mathbfbarx of length 2N and covariance matrix mathbfV of size 2Ntimes 2N. By definition, the Wigner representation of a Gaussian state is a Gaussian function.\n\nExample\n\njulia> coherentstate(QuadPairBasis(1), 1.0+im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"Functions to create instances of elementary Gaussian states are provided as part of the package API.  Listed below are supported predefined Gaussian states:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"vacuumstate\nthermalstate\ncoherentstate\nsqueezedstate\neprstate","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Detailed discussions and mathematical descriptions for each of these states are given in the Gaussian Zoos page.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If we were operating in the state (Fock) space, and wanted to describe multi-mode Gaussian states, we would take the tensor product of multiple density operators. That method, however, is quite computationally expensive and requires a finite truncation of the Fock basis. To create such state vector simulations, we recommend using the QuantumOptics.jl library. For our purposes in the phase space, we can manually create multi-mode Gaussian systems with a tensor product, which can be called with either tensor or ⊗, the Kronecker product symbol which can be typed in the Julia REPL as \\otimes<TAB>. Take the following example, where we produce a 3-mode Gaussian state that consists of a coherent state, vacuumstate, and squeezed state:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> basis = QuadPairBasis(1);\n\njulia> coherentstate(basis, -1.0+im) ⊗ vacuumstate(basis) ⊗ squeezedstate(basis, 0.25, pi/4)\nGaussianState for 3 modes.\n  symplectic basis: QuadPairBasis\nmean: 6-element Vector{Float64}:\n -1.4142135623730951\n  1.4142135623730951\n  0.0\n  0.0\n  0.0\n  0.0\ncovariance: 6×6 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0       0.0\n 0.0  1.0  0.0  0.0  0.0       0.0\n 0.0  0.0  1.0  0.0  0.0       0.0\n 0.0  0.0  0.0  1.0  0.0       0.0\n 0.0  0.0  0.0  0.0  0.379578  0.184235\n 0.0  0.0  0.0  0.0  0.184235  0.748048","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that in the above example, we defined the symplectic basis to be of type QuadPairBasis. If we wanted the canonical field operators to be ordered blockwise, then we would call QuadBlockBasis instead:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> basis = QuadBlockBasis(1);\n\njulia> coherentstate(basis, -1.0+im) ⊗ vacuumstate(basis) ⊗ squeezedstate(basis, 0.25, pi/4)\nGaussianState for 3 modes.\n  symplectic basis: QuadBlockBasis\nmean: 6-element Vector{Float64}:\n -1.4142135623730951\n  0.0\n  0.0\n  1.4142135623730951\n  0.0\n  0.0\ncovariance: 6×6 Matrix{Float64}:\n 1.0  0.0  0.0       0.0  0.0  0.0\n 0.0  1.0  0.0       0.0  0.0  0.0\n 0.0  0.0  0.379578  0.0  0.0  0.184235\n 0.0  0.0  0.0       1.0  0.0  0.0\n 0.0  0.0  0.0       0.0  1.0  0.0\n 0.0  0.0  0.184235  0.0  0.0  0.748048","category":"page"},{"location":"manual/#Gaussian-Operators","page":"Manual","title":"Gaussian Operators","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To transform Gaussian states into Gaussian states, we need Gaussian maps. There are various ways to construct Gaussian transformations, which we will discuss in this section.","category":"page"},{"location":"manual/#Gaussian-Unitaries","page":"Manual","title":"Gaussian Unitaries","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's begin with the simplest Gaussian transformation, a unitary transformation, which can be created with the GaussianUnitary type:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"GaussianUnitary","category":"page"},{"location":"manual/#Gabs.GaussianUnitary-manual","page":"Manual","title":"Gabs.GaussianUnitary","text":"Defines a Gaussian unitary for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic basis for Gaussian unitary.\ndisp: The displacement vector of length 2N.\nsymplectic: The symplectic matrix of size 2N x 2N.\n\nMathematical description of a Gaussian unitary\n\nAn N-mode Gaussian unitary, U(mathbfd mathbfS), is a unitary operator characterized by a displacement vector mathbfd of length 2N and symplectic matrix mathbfS of size 2Ntimes 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian unitary transformation on a Gaussian state hatrho(mathbfbarx mathbfV) is described by its maps on the statistical moments of the Gaussian state:\n\nmathbfbarx to mathbfS mathbfbarx + mathbfd quad\nmathbfV to mathbfS mathbfV mathbfS^textT\n\nExample\n\njulia> displace(QuadPairBasis(1), 1.0+im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"This is a rather clean way to characterize a large group of Gaussian transformations on an N-mode Gaussian bosonic system. As long as we have a displacement vector of size 2N and symplectic matrix of size 2N x 2N, we can create a Gaussian transformation. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This library has a number of predefined Gaussian unitaries, which are listed below:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"displace\nsqueeze\ntwosqueeze\nphaseshift\nbeamsplitter","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Detailed discussions and mathematical descriptions for each of these unitaries are given in the Gaussian Zoos page.","category":"page"},{"location":"manual/#Gaussian-Channels","page":"Manual","title":"Gaussian Channels","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Noisy bosonic channels are an important model for describing the interaction between a Gaussian state and its environment. Similar to Gaussian unitaries, Gaussian channels are linear bosonic channels that map Gaussian states to Gaussian states. Such objects can be created with the GaussianChannel type:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"GaussianChannel","category":"page"},{"location":"manual/#Gabs.GaussianChannel-manual","page":"Manual","title":"Gabs.GaussianChannel","text":"Defines a Gaussian channel for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic representation for Gaussian channel.\ndisp: The displacement vector of length 2N.\ntransform: The transformation matrix of size 2N x 2N.\nnoise: The noise matrix of size 2N x 2N.\n\nMathematical description of a Gaussian channel\n\nAn N-mode Gaussian channel, G(mathbfd mathbfT mathbfN), is an operator characterized by a displacement vector mathbfd of length 2N, as well as a transformation matrix mathbfT and noise matrix mathbfN of size 2Ntimes 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian channel action on a Gaussian state hatrho(mathbfbarx mathbfV) is described by its maps on the statistical moments of the Gaussian state:\n\nmathbfbarx to mathbfT mathbfbarx + mathbfd quad\nmathbfV to mathbfT mathbfV mathbfT^textT + mathbfN\n\nExample\n\njulia> noise = [1.0 -3.0; 4.0 2.0];\n\njulia> displace(QuadPairBasis(1), 1.0+im, noise)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ntransform: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\nnoise: 2×2 Matrix{Float64}:\n 1.0  -3.0\n 4.0   2.0\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"Listed below are a list of predefined Gaussian channels supported by Gabs:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"attenuator\namplifier","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nWhen its noise matrix mathbfN = mathbf0 and transform operator mathbfT is a symplectic matrix, a Gaussian channel is a unitary operator. Any predefined Gaussian unitary method can be called with an additional noise matrix to create a GaussianChannel object. For instance, a noisy displacement operator can be called with displace as follows:julia> basis = QuadPairBasis(1);\n\njulia> noise = [1.0 -2.0; 4.0 -3.0];\n\njulia> displace(basis, 1.0-im, noise)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n  1.4142135623730951\n -1.4142135623730951\ntransform: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\nnoise: 2×2 Matrix{Float64}:\n 1.0  -2.0\n 4.0  -3.0","category":"page"},{"location":"zoos/#Gaussian-Zoos","page":"Gaussian Zoos","title":"Gaussian Zoos","text":"","category":"section"},{"location":"zoos/#State-Zoo","page":"Gaussian Zoos","title":"State Zoo","text":"","category":"section"},{"location":"zoos/","page":"Gaussian Zoos","title":"Gaussian Zoos","text":"vacuumstate\nthermalstate\ncoherentstate\nsqueezedstate\neprstate","category":"page"},{"location":"zoos/#Gabs.vacuumstate-zoos","page":"Gaussian Zoos","title":"Gabs.vacuumstate","text":"vacuumstate([Tm=Vector{Float64}, Tc=Matrix{Float64}], basis::SymplecticBasis)\n\nGaussian state with zero photons, known as the vacuum state. The symplectic representation is defined by basis.\n\nMathematical description of a vacuum state\n\nA vacuum state 0rangle is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0 quad mathbfV = mathbfI\n\nExample\n\njulia> vacuumstate(QuadPairBasis(1))\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.thermalstate-zoos","page":"Gaussian Zoos","title":"Gabs.thermalstate","text":"thermalstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, photons<:Int)\n\nGaussian state at thermal equilibrium, known as the thermal state. The symplectic representation is defined by basis. The mean photon number of the state is given by photons.\n\nMathematical description of a thermal state\n\nA thermal state barnrangle, where barn is the mean number of photons, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0 quad mathbfV = left(barn + frac12right)mathbfI\n\nExample\n\njulia> thermalstate(QuadPairBasis(1), 4)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 4.5  0.0\n 0.0  4.5\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.coherentstate-zoos","page":"Gaussian Zoos","title":"Gabs.coherentstate","text":"coherentstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, alpha<:Number)\n\nGaussian state that is the quantum analogue of a monochromatic electromagnetic field, known as the coherent state. The symplectic representation is defined by basis. The complex amplitude of the state is given by alpha.\n\nMathematical description of a coherent state\n\nA coherent state alpharangle, where alpha is the complex amplitude, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = sqrt2left(textRe(alpha) textIm(alpha)right)^textT\nquad mathbfV = mathbfI\n\nExample\n\njulia> coherentstate(QuadPairBasis(1), 1.0+im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.squeezedstate-zoos","page":"Gaussian Zoos","title":"Gabs.squeezedstate","text":"squeezedstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, r<:Real, theta<:Real)\n\nGaussian state with quantum uncertainty in its phase and amplitude, known as the squeezed state. The symplectic representation is defined by basis. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of a squeezed state\n\nA squeezed state r thetarangle, where r is the amplitude squeezing parameter and theta is the phase squeezing parameter, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0\nquad mathbfV = frac12left(cosh(2r)mathbfI - sinh(2r)mathbfR(theta)right)\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> squeezedstate(QuadPairBasis(1), 0.5, pi/4)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 0.356044  0.415496\n 0.415496  1.18704\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.eprstate-zoos","page":"Gaussian Zoos","title":"Gabs.eprstate","text":"eprstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, r<:Real, theta<:Real)\n\nGaussian state that is a two-mode squeezed state, known as the Einstein-Podolski-Rosen (EPR) state. The symplectic representation is defined by basis. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of an EPR state\n\nAn EPR state r thetarangle_textEPR, where r is the amplitude squeezing parameter and theta is the phase squeezing parameter, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0\nquad mathbfV = frac12beginpmatrix\n                                    cosh(2r)mathbfI  -sinh(2r)mathbfR(theta) \n                                    -sinh(2r)mathbfR(theta)  cosh(2r)mathbfI \n                                    endpmatrix\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> eprstate(QuadPairBasis(2), 0.5, pi/4)\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n  0.77154    0.0       -0.415496  -0.415496\n  0.0        0.77154   -0.415496   0.415496\n -0.415496  -0.415496   0.77154    0.0\n -0.415496   0.415496   0.0        0.77154\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Operator-Zoo","page":"Gaussian Zoos","title":"Operator Zoo","text":"","category":"section"},{"location":"zoos/","page":"Gaussian Zoos","title":"Gaussian Zoos","text":"displace\nsqueeze\ntwosqueeze\nphaseshift\nbeamsplitter\nattenuator\namplifier","category":"page"},{"location":"zoos/#Gabs.displace-zoos","page":"Gaussian Zoos","title":"Gabs.displace","text":"displace([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, alpha<:Number)\ndisplace([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, alpha<:Number, noise::Ts)\n\nGaussian operator that displaces the vacuum state into a coherent state, known as the displacement operator. The symplectic representation is given by basis. The complex amplitude is given by alpha. Noise can be added to the operation with noise.\n\nMathematical description of a displacement operator\n\nA displacement operator D(alpha) is defined by the operation D(alpha)0rangle = alpharangle, where alpha is a complex amplitude. The operator D(alpha) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = sqrt2left(textRe(alpha) textIm(alpha)right)^textT\nquad mathbfS = mathbfI\n\nExample\n\njulia> displace(QuadPairBasis(1), 1.0+im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.squeeze-zoos","page":"Gaussian Zoos","title":"Gabs.squeeze","text":"squeeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real)\nsqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes the vacuum state into a squeezed state, known as the squeezing operator. The symplectic representation is given by basis. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a squeezing operator\n\nA squeeze operator S(r theta) is defined by the operation S(r theta)0rangle = r thetarangle, where r and theta are the real amplitude and phase parameters, respectively. The operator  S(r theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = cosh(r)mathbfI - sinh(r)mathbfR(theta)\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> squeeze(QuadPairBasis(1), 0.25, pi/4)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n  0.852789  -0.178624\n -0.178624   1.21004\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.twosqueeze-zoos","page":"Gaussian Zoos","title":"Gabs.twosqueeze","text":"twosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real)\ntwosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes a two-mode vacuum state into a two-mode squeezed state, known as the two-mode squeezing operator. The symplectic representation is given by basis. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a two-mode squeezing operator\n\nA two-mode squeeze operator S_2(r theta) is defined by the operation S_2(r theta)0rangle = r thetarangle, where r and theta are the real amplitude and phase parameters, respectively. The operator  S_2(r theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                    cosh(r)mathbfI  -sinh(r)mathbfR(theta) \n                    -sinh(r)mathbfR(theta)  cosh(r)mathbfI \n                    endpmatrix\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> twosqueeze(QuadPairBasis(2), 0.25, pi/4)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  1.03141    0.0       -0.178624  -0.178624\n  0.0        1.03141   -0.178624   0.178624\n -0.178624  -0.178624   1.03141    0.0\n -0.178624   0.178624   0.0        1.03141\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.phaseshift-zoos","page":"Gaussian Zoos","title":"Gabs.phaseshift","text":"phaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, theta<:Real)\nphaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, theta<:Real, noise::Ts)\n\nGaussian operator that rotates the phase of a given Gaussian mode by theta, as the phase shift operator. The symplectic representation is given by basis. Noise can be added to the operation with noise.\n\nMathematical description of a phase shift operator\n\nA phase shift operator U(theta) is defined by the operation U(Theta) = exp(-ithetahata^daggerhata), where theta is the phase parameter, and hata^dagger and hata are the raising and lowering operators, respectively. The operator  U(theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                        cos(theta)  sin(theta) \n                        -sin(theta)  cos(theta) \n                     endpmatrix\n\nExample\n\njulia> phaseshift(QuadPairBasis(1), 3pi/4)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n -0.707107   0.707107\n -0.707107  -0.707107\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.beamsplitter-zoos","page":"Gaussian Zoos","title":"Gabs.beamsplitter","text":"beamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, transmit<:Real)\nbeamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, transmit<:Real, noise::Ts)\n\nGaussian operator that serves as the beam splitter transformation of a two-mode Gaussian state, known as the beam splitter operator. The symplectic representation is given by basis. The transmittivity of the operator is given by transmit. Noise can be added to the operation with noise.\n\nMathematical description of a beam splitter operator\n\nA beam splitter operator B(tau) is defined by the operation B(theta) = explefttheta(hata^daggerhatb - hatahatb^dagger)right, where theta is defined by tau = cos^2theta, and hata and hatb are the annihilation operators of the two modes, respectively. The operator  B(tau) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                        sqrttaumathbfI  sqrt1-taumathbfI \n                        -sqrt1-taumathbfI  sqrttaumathbfI \n                     endpmatrix\n\nExample\n\njulia> beamsplitter(QuadPairBasis(2), 0.75)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  0.5        0.0       0.866025  0.0\n  0.0        0.5       0.0       0.866025\n -0.866025   0.0       0.5       0.0\n  0.0       -0.866025  0.0       0.5\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.attenuator-zoos","page":"Gaussian Zoos","title":"Gabs.attenuator","text":"attenuator([Td=Vector{Float64}, Tt=Matrix{Float64},] basis::SymplecticBasis, theta<:Real, n<:Int)\n\nGaussian channel describing the coupling of an input single mode Gaussian state and its environment via a beam splitter operation. The channel is paramatrized by beam splitter rotation angle theta and thermal noise n.\n\nMathematical description of an attenuator channel\n\nAn attenuator channel, mathcalE_theta^n_textth, where theta is the beam splitter rotation parameter and n_textth geq 1 is the thermal noise parameter, is characterized by the displacement vector mathbfd, transformation matrix mathbfT, and noise matrix mathbfN, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfT = costhetamathbfI\nqquad mathbfN = (sintheta)^2 n_textth mathbfI\n\nExample\n\njulia> attenuator(QuadPairBasis(1), pi/6, 3)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 0.866025  0.0\n 0.0       0.866025\nnoise: 2×2 Matrix{Float64}:\n 0.75  0.0\n 0.0   0.75\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.amplifier-zoos","page":"Gaussian Zoos","title":"Gabs.amplifier","text":"amplifier([Td=Vector{Float64}, Tt=Matrix{Float64},] basis::SymplecticBasis, r<:Real, n<:Int)\n\nGaussian channel describing the interaction of an input single mode Gaussian state and its environment via a two-mode squeezing operation. The channel is paramatrized by squeezing amplitude parameter r and thermal noise n.\n\nMathematical description of an amplifier channel\n\nAn amplifier channel, mathcalA_theta^n_textth, where r is the squeezing amplitude parameter and n_textth geq 1 is the thermal noise parameter, is characterized by the displacement vector mathbfd, transformation matrix mathbfT, and noise matrix mathbfN, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfT = cosh rmathbfI\nqquad mathbfN = (sinh r)^2 n_textth mathbfI\n\nExample\n\njulia> amplifier(QuadPairBasis(1), 2.0, 3)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 3.7622  0.0\n 0.0     3.7622\nnoise: 2×2 Matrix{Float64}:\n 39.4623   0.0\n  0.0     39.4623\n\n\n\n\n\n","category":"function"},{"location":"bibliography/#References","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"","category":"section"},{"location":"bibliography/#Tutorials-on-Gaussian-Quantum-Information","page":"Suggested Readings and References","title":"Tutorials on Gaussian Quantum Information","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Adesso, G.; Ragy, S. and Lee, A. R. (2014). Continuous Variable Quantum Information: Gaussian States and Beyond. Open Systems & Information Dynamics 21, 1440001.\n\n\n\nOlivares, S. (2011). Quantum optics in the phase space. The European Physical Journal Special Topics 203, 3–24.\n\n\n\nWang, X.-B.; Hiroshima, T.; Tomita, A. and Hayashi, M. (2007). Quantum information with Gaussian states. Physics Reports 448, 1–111.\n\n\n\nWeedbrook, C.; Pirandola, S.; Garcı́a-Patrón, R.; Cerf, N. J.; Ralph, T. C.; Shapiro, J. H. and Lloyd, S. (2012). Gaussian quantum information. Rev. Mod. Phys. 84, 621–669.\n\n\n\n","category":"page"},{"location":"bibliography/#Tutorials-and-Books-on-Quantum-Continuous-Variables","page":"Suggested Readings and References","title":"Tutorials and Books on Quantum Continuous Variables","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Braunstein, S. L. and van Loock, P. (2005). Quantum information with continuous variables. Rev. Mod. Phys. 77, 513–577.\n\n\n\nCerf, N. J.; Leuchs, G. and Polzik, E. S. (2007). Quantum Information with Continuous Variables of Atoms and Light (Imperial College Press).\n\n\n\nSerafini, A. (2023). Quantum Continuous Variables: A Primer of Theoretical Methods (CRC Press).\n\n\n\nWalschaers, M. (2021). Non-Gaussian Quantum States and Where to Find Them. PRX Quantum 2, 030204.\n\n\n\n","category":"page"},{"location":"bibliography/#Technical-Reviews-on-Quantum-Continuous-Variables","page":"Suggested Readings and References","title":"Technical Reviews on Quantum Continuous Variables","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Andersen, U.; Leuchs, G. and Silberhorn, C. (2010). Continuous-variable quantum information processing. Laser & Photonics Reviews 4, 337–354.\n\n\n\nCerf, N. J. and Grangier, P. (2007). From quantum cloning to quantum key distribution with continuous variables: a review (Invited). J. Opt. Soc. Am. B 24, 324–334.\n\n\n\nFukui, K. and Takeda, S. (2022). Building a large-scale quantum computer with continuous-variable optical technologies. Journal of Physics B: Atomic, Molecular and Optical Physics 55, 012001.\n\n\n\nGoldberg, A. Z.; Klimov, A. B.; Grassl, M.; Leuchs, G. and Sánchez-Soto, L. L. (2020). Extremal quantum states. AVS Quantum Science 2, 044701.\n\n\n\nJankowski, M.; Yanagimoto, R.; Ng, E.; Hamerly, R.; McKenna, T. P.; Mabuchi, H. and Fejer, M. M. (2024). Ultrafast second-order nonlinear photonics—from classical physics to non-Gaussian quantum dynamics: a tutorial. Adv. Opt. Photon. 16, 347–538.\n\n\n\nvan Loock, P. (2002). Quantum Communication with Continuous Variables. Fortschritte der Physik 50, 1177–1372.\n\n\n\nLvovsky, A. I. and Raymer, M. G. (2009). Continuous-variable optical quantum-state tomography. Rev. Mod. Phys. 81, 299–332.\n\n\n\nPirandola, S. and Mancini, S. (2006). Quantum teleportation with continuous variables: A survey. Laser Physics 16, 1418–1438.\n\n\n\n","category":"page"},{"location":"bibliography/#Publications-on-Gaussian-Quantum-Measurements","page":"Suggested Readings and References","title":"Publications on Gaussian Quantum Measurements","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Cenni, M. F.; Lami, L.; Acín, A. and Mehboudi, M. (2022). Thermometry of Gaussian quantum systems using Gaussian measurements. Quantum 6, 743.\n\n\n\nKiukas, J. and Schultz, J. (2013). Informationally complete sets of Gaussian measurements. Journal of Physics A: Mathematical and Theoretical 46, 485303.\n\n\n\nMarco G. Genoni, L. L. and Serafini, A. (2016). Conditional and unconditional Gaussian quantum dynamics. Contemporary Physics 57, 331–349.\n\n\n\nZhang, J. (2018). Quantum measurement and preparation of Gaussian states. Ph.D. Thesis, Aarhus University.\n\n\n\n","category":"page"},{"location":"#Gabs.jl","page":"Gabs.jl","title":"Gabs.jl","text":"","category":"section"},{"location":"","page":"Gabs.jl","title":"Gabs.jl","text":"DocTestSetup = quote\n    using Gabs\nend","category":"page"},{"location":"","page":"Gabs.jl","title":"Gabs.jl","text":"A numerical package for simulating Gaussian quantum information in the phase space representation.","category":"page"},{"location":"","page":"Gabs.jl","title":"Gabs.jl","text":"Visit the getting started page for an introduction to Gabs and its documentation.","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [Gabs, QuantumInterface]\nPrivate = false","category":"page"},{"location":"API/#Gabs.GaussianChannel","page":"API","title":"Gabs.GaussianChannel","text":"Defines a Gaussian channel for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic representation for Gaussian channel.\ndisp: The displacement vector of length 2N.\ntransform: The transformation matrix of size 2N x 2N.\nnoise: The noise matrix of size 2N x 2N.\n\nMathematical description of a Gaussian channel\n\nAn N-mode Gaussian channel, G(mathbfd mathbfT mathbfN), is an operator characterized by a displacement vector mathbfd of length 2N, as well as a transformation matrix mathbfT and noise matrix mathbfN of size 2Ntimes 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian channel action on a Gaussian state hatrho(mathbfbarx mathbfV) is described by its maps on the statistical moments of the Gaussian state:\n\nmathbfbarx to mathbfT mathbfbarx + mathbfd quad\nmathbfV to mathbfT mathbfV mathbfT^textT + mathbfN\n\nExample\n\njulia> noise = [1.0 -3.0; 4.0 2.0];\n\njulia> displace(QuadPairBasis(1), 1.0+im, noise)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ntransform: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\nnoise: 2×2 Matrix{Float64}:\n 1.0  -3.0\n 4.0   2.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.GaussianState","page":"API","title":"Gabs.GaussianState","text":"Defines a Gaussian state for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic basis for Gaussian state.\nmean: The mean vector of length 2N.\ncovar: The covariance matrix of size 2N x 2N.\n\nMathematical description of a Gaussian state\n\nAn N-mode Gaussian state, hatrho(mathbfbarx mathbfV), is a density operator characterized by two statistical moments: a mean vector mathbfbarx of length 2N and covariance matrix mathbfV of size 2Ntimes 2N. By definition, the Wigner representation of a Gaussian state is a Gaussian function.\n\nExample\n\njulia> coherentstate(QuadPairBasis(1), 1.0+im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.GaussianUnitary","page":"API","title":"Gabs.GaussianUnitary","text":"Defines a Gaussian unitary for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nbasis: Symplectic basis for Gaussian unitary.\ndisp: The displacement vector of length 2N.\nsymplectic: The symplectic matrix of size 2N x 2N.\n\nMathematical description of a Gaussian unitary\n\nAn N-mode Gaussian unitary, U(mathbfd mathbfS), is a unitary operator characterized by a displacement vector mathbfd of length 2N and symplectic matrix mathbfS of size 2Ntimes 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian unitary transformation on a Gaussian state hatrho(mathbfbarx mathbfV) is described by its maps on the statistical moments of the Gaussian state:\n\nmathbfbarx to mathbfS mathbfbarx + mathbfd quad\nmathbfV to mathbfS mathbfV mathbfS^textT\n\nExample\n\njulia> displace(QuadPairBasis(1), 1.0+im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.Generaldyne","page":"API","title":"Gabs.Generaldyne","text":"Defines a partial general-dyne measurement of a Gaussian system.\n\nFields\n\nsystem: Initial Gaussian state.\noutcome: Measurement outcome Gaussian state.\nindices: Specific indices of system that are projected onto outcome.\n\nMathematical description of a general-dyne measurement\n\nA partial general-dyne measurement on a Gaussian state hatrho(mathbfbarx mathbfV) of a system partitioned into subsystems A and B is a projection of subsystem B onto a measurement outcome Gaussian state hatrho(mathbfbarx_m mathbfV_m).\n\nExample\n\njulia> basis = QuadPairBasis(1);\n\njulia> vac = vacuumstate(basis); coh = coherentstate(basis, 1.0-im);\n\njulia> state = vac ⊗ coh ⊗ vac ⊗ coh\nGaussianState for 4 modes.\n  symplectic basis: QuadPairBasis\nmean: 8-element Vector{Float64}:\n  0.0\n  0.0\n  1.4142135623730951\n -1.4142135623730951\n  0.0\n  0.0\n  1.4142135623730951\n -1.4142135623730951\ncovariance: 8×8 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0\n\njulia> Generaldyne(state, coh ⊗ vac ⊗ coh, [1, 3, 4])\nGeneraldyne on indices [1, 3, 4]\nsystem: GaussianState for 4 modes.\n (xType: Vector{Float64} | vType: Matrix{Float64})\noutcome: GaussianState for 3 modes.\n (xType: Vector{Float64} | vType: Matrix{Float64})\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.QuadBlockBasis","page":"API","title":"Gabs.QuadBlockBasis","text":"Defines a symplectic basis for a bosonic system of size nmodes in which the quadrature field operators are arranged blockwise.\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.QuadPairBasis","page":"API","title":"Gabs.QuadPairBasis","text":"Defines a symplectic basis for a bosonic system of size nmodes in which the quadrature field operators are arranged pairwise.\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.amplifier-Union{Tuple{M}, Tuple{R}, Tuple{N}, Tuple{Tt}, Tuple{Td}, Tuple{Type{Td}, Type{Tt}, Gabs.SymplecticBasis{N}, R, M}} where {Td, Tt, N<:Int64, R, M}","page":"API","title":"Gabs.amplifier","text":"amplifier([Td=Vector{Float64}, Tt=Matrix{Float64},] basis::SymplecticBasis, r<:Real, n<:Int)\n\nGaussian channel describing the interaction of an input single mode Gaussian state and its environment via a two-mode squeezing operation. The channel is paramatrized by squeezing amplitude parameter r and thermal noise n.\n\nMathematical description of an amplifier channel\n\nAn amplifier channel, mathcalA_theta^n_textth, where r is the squeezing amplitude parameter and n_textth geq 1 is the thermal noise parameter, is characterized by the displacement vector mathbfd, transformation matrix mathbfT, and noise matrix mathbfN, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfT = cosh rmathbfI\nqquad mathbfN = (sinh r)^2 n_textth mathbfI\n\nExample\n\njulia> amplifier(QuadPairBasis(1), 2.0, 3)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 3.7622  0.0\n 0.0     3.7622\nnoise: 2×2 Matrix{Float64}:\n 39.4623   0.0\n  0.0     39.4623\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.attenuator-Union{Tuple{M}, Tuple{R}, Tuple{N}, Tuple{Tt}, Tuple{Td}, Tuple{Type{Td}, Type{Tt}, Gabs.SymplecticBasis{N}, R, M}} where {Td, Tt, N<:Int64, R, M}","page":"API","title":"Gabs.attenuator","text":"attenuator([Td=Vector{Float64}, Tt=Matrix{Float64},] basis::SymplecticBasis, theta<:Real, n<:Int)\n\nGaussian channel describing the coupling of an input single mode Gaussian state and its environment via a beam splitter operation. The channel is paramatrized by beam splitter rotation angle theta and thermal noise n.\n\nMathematical description of an attenuator channel\n\nAn attenuator channel, mathcalE_theta^n_textth, where theta is the beam splitter rotation parameter and n_textth geq 1 is the thermal noise parameter, is characterized by the displacement vector mathbfd, transformation matrix mathbfT, and noise matrix mathbfN, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfT = costhetamathbfI\nqquad mathbfN = (sintheta)^2 n_textth mathbfI\n\nExample\n\njulia> attenuator(QuadPairBasis(1), pi/6, 3)\nGaussianChannel for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 0.866025  0.0\n 0.0       0.866025\nnoise: 2×2 Matrix{Float64}:\n 0.75  0.0\n 0.0   0.75\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.beamsplitter-Union{Tuple{R}, Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}, R}} where {Td, Ts, N<:Int64, R}","page":"API","title":"Gabs.beamsplitter","text":"beamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, transmit<:Real)\nbeamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, transmit<:Real, noise::Ts)\n\nGaussian operator that serves as the beam splitter transformation of a two-mode Gaussian state, known as the beam splitter operator. The symplectic representation is given by basis. The transmittivity of the operator is given by transmit. Noise can be added to the operation with noise.\n\nMathematical description of a beam splitter operator\n\nA beam splitter operator B(tau) is defined by the operation B(theta) = explefttheta(hata^daggerhatb - hatahatb^dagger)right, where theta is defined by tau = cos^2theta, and hata and hatb are the annihilation operators of the two modes, respectively. The operator  B(tau) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                        sqrttaumathbfI  sqrt1-taumathbfI \n                        -sqrt1-taumathbfI  sqrttaumathbfI \n                     endpmatrix\n\nExample\n\njulia> beamsplitter(QuadPairBasis(2), 0.75)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  0.5        0.0       0.866025  0.0\n  0.0        0.5       0.0       0.866025\n -0.866025   0.0       0.5       0.0\n  0.0       -0.866025  0.0       0.5\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.coherentstate-Union{Tuple{A}, Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}, A}} where {Tm, Tc, N<:Int64, A}","page":"API","title":"Gabs.coherentstate","text":"coherentstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, alpha<:Number)\n\nGaussian state that is the quantum analogue of a monochromatic electromagnetic field, known as the coherent state. The symplectic representation is defined by basis. The complex amplitude of the state is given by alpha.\n\nMathematical description of a coherent state\n\nA coherent state alpharangle, where alpha is the complex amplitude, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = sqrt2left(textRe(alpha) textIm(alpha)right)^textT\nquad mathbfV = mathbfI\n\nExample\n\njulia> coherentstate(QuadPairBasis(1), 1.0+im)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.displace-Union{Tuple{A}, Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}, A}} where {Td, Ts, N<:Int64, A}","page":"API","title":"Gabs.displace","text":"displace([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, alpha<:Number)\ndisplace([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, alpha<:Number, noise::Ts)\n\nGaussian operator that displaces the vacuum state into a coherent state, known as the displacement operator. The symplectic representation is given by basis. The complex amplitude is given by alpha. Noise can be added to the operation with noise.\n\nMathematical description of a displacement operator\n\nA displacement operator D(alpha) is defined by the operation D(alpha)0rangle = alpharangle, where alpha is a complex amplitude. The operator D(alpha) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = sqrt2left(textRe(alpha) textIm(alpha)right)^textT\nquad mathbfS = mathbfI\n\nExample\n\njulia> displace(QuadPairBasis(1), 1.0+im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.eprstate-Union{Tuple{R}, Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}, R, R}} where {Tm, Tc, N<:Int64, R}","page":"API","title":"Gabs.eprstate","text":"eprstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, r<:Real, theta<:Real)\n\nGaussian state that is a two-mode squeezed state, known as the Einstein-Podolski-Rosen (EPR) state. The symplectic representation is defined by basis. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of an EPR state\n\nAn EPR state r thetarangle_textEPR, where r is the amplitude squeezing parameter and theta is the phase squeezing parameter, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0\nquad mathbfV = frac12beginpmatrix\n                                    cosh(2r)mathbfI  -sinh(2r)mathbfR(theta) \n                                    -sinh(2r)mathbfR(theta)  cosh(2r)mathbfI \n                                    endpmatrix\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> eprstate(QuadPairBasis(2), 0.5, pi/4)\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n  0.77154    0.0       -0.415496  -0.415496\n  0.0        0.77154   -0.415496   0.415496\n -0.415496  -0.415496   0.77154    0.0\n -0.415496   0.415496   0.0        0.77154\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.isgaussian-Union{Tuple{GaussianState}, Tuple{R2}, Tuple{R1}} where {R1<:Real, R2<:Real}","page":"API","title":"Gabs.isgaussian","text":"isgaussian(x::GaussianState)\nisgaussian(x::GaussianUnitary)\nisgaussian(x::GaussianChannel)\n\nCheck if x satisfies the corresponding Gaussian definition for its type.\n\nExample\n\njulia> basis = QuadPairBasis(1);\n\njulia> op = displace(basis, 1.0-im)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n  1.4142135623730951\n -1.4142135623730951\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\njulia> isgaussian(op)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.issymplectic-Union{Tuple{R2}, Tuple{R1}, Tuple{T}, Tuple{Gabs.SymplecticBasis, T}} where {T, R1<:Real, R2<:Real}","page":"API","title":"Gabs.issymplectic","text":"issymplectic(basis::SymplecticBasis, x::T)\n\nCheck if input matrix satisfies symplectic definition.\n\nExample\n\njulia> basis = QuadPairBasis(1);\n\njulia> issymplectic(basis, [1.0 0.0; 0.0 1.0])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.output-Tuple{Generaldyne}","page":"API","title":"Gabs.output","text":"output(meas::Generaldyne)\n\nConditional mapping of the subsystem for the initial Gaussian system that is not measured  in a Generaldyne object.\n\nMathematical description of conditional evolution of a Gaussian system\n\nLet hatrho(mathbfbarx mathbfV) be a Gaussian state of a system partitioned into subsystems A and B, such that\n\nmathbfbarx = beginpmatrix \n                        mathbfbarx_textA  mathbfbarx_textA \n                    endpmatrix^textT\nquad mathbfV = beginpmatrix \n                        mathbfV_textA  mathbfV_textAB \n                        mathbfV_textAB^textT  mathbfV_textB\n                    endpmatrix\n\nwhere (mathbfbarx_textA mathbfV_textA) and  (mathbfbarx_textB mathbfV_textB) are the mean and covariance matrices of subsystems A and B, respectively. Here mathbfV_textAB is a covariance matrix representing the correlations between A and B. If we project subsystem B onto a measurement outcome hatrho(mathbfbarx_m mathbfV_m), then subsystem A conditionally maps as follows:\n\nmathbfbarx_textA to mathbfbarx_textA + \n    fracmathbfV_textABmathbfV_textB + mathbfV_m(mathbfbarx_m - mathbfbarx_textB)^textT\nquadmathbfV_textA to mathbfV_textA - \n    fracmathbfV_textABmathbfV_textB + mathbfV_m mathbfV_textAB^textT\n\nExample\n\njulia> basis = QuadPairBasis(1);\n\njulia> vac = vacuumstate(basis); coh = coherentstate(basis, 1.0-im);\n\njulia> state = vac ⊗ coh ⊗ vac ⊗ coh\nGaussianState for 4 modes.\n  symplectic basis: QuadPairBasis\nmean: 8-element Vector{Float64}:\n  0.0\n  0.0\n  1.4142135623730951\n -1.4142135623730951\n  0.0\n  0.0\n  1.4142135623730951\n -1.4142135623730951\ncovariance: 8×8 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0\n\njulia> gd = Generaldyne(state, coh ⊗ vac ⊗ coh, [1, 3, 4])\nGeneraldyne on indices [1, 3, 4]\nsystem: GaussianState for 4 modes.\n (xType: Vector{Float64} | vType: Matrix{Float64})\noutcome: GaussianState for 3 modes.\n (xType: Vector{Float64} | vType: Matrix{Float64})\n\njulia> output(gd)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n  1.4142135623730951\n -1.4142135623730951\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.phaseshift-Union{Tuple{R}, Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}, R}} where {Td, Ts, N<:Int64, R}","page":"API","title":"Gabs.phaseshift","text":"phaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, theta<:Real)\nphaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, theta<:Real, noise::Ts)\n\nGaussian operator that rotates the phase of a given Gaussian mode by theta, as the phase shift operator. The symplectic representation is given by basis. Noise can be added to the operation with noise.\n\nMathematical description of a phase shift operator\n\nA phase shift operator U(theta) is defined by the operation U(Theta) = exp(-ithetahata^daggerhata), where theta is the phase parameter, and hata^dagger and hata are the raising and lowering operators, respectively. The operator  U(theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                        cos(theta)  sin(theta) \n                        -sin(theta)  cos(theta) \n                     endpmatrix\n\nExample\n\njulia> phaseshift(QuadPairBasis(1), 3pi/4)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n -0.707107   0.707107\n -0.707107  -0.707107\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.prob-Tuple{Generaldyne}","page":"API","title":"Gabs.prob","text":"prob(meas::Generaldyne)\n\nCalculate the probability density of a general-dyne measurement.\n\nMathematical description of probability density of a general-dyne measurement\n\nLet hatrho(mathbfbarx mathbfV) be a Gaussian state of a system partitioned into subsystems A and B, such that\n\nmathbfbarx = beginpmatrix \n                        mathbfbarx_textA  mathbfbarx_textA \n                    endpmatrix^textT\nquad mathbfV = beginpmatrix \n                        mathbfV_textA  mathbfV_textAB \n                        mathbfV_textAB^textT  mathbfV_textB\n                    endpmatrix\n\nwhere (mathbfbarx_textA mathbfV_textA) and  (mathbfbarx_textB mathbfV_textB) are the mean and covariance matrices of subsystems A and B, respectively. Here mathbfV_textAB is a covariance matrix representing the correlations between A and B. If we project subsystem B onto a measurement outcome hatrho(mathbfbarx_m mathbfV_m), then the probability density in dmathbfhatx_m is\n\np(mathbfbarx_m) = frace^(mathbfbarx_m - mathbfbarx_textB)^textT \n    frac1mathbfV_textB + mathbfV_m (mathbfbarx_m - mathbfbarx_textB)pi^m \n    sqrtdet(mathbfV_textB + mathbfV_m)\n\nwhere m is the number of modes in subsystem B.\n\nExample\n\njulia> basis = QuadPairBasis(1);\n\njulia> vac = vacuumstate(basis); coh = coherentstate(basis, 1.0-im);\n\njulia> state = vac ⊗ coh ⊗ vac ⊗ coh\nGaussianState for 4 modes.\n  symplectic basis: QuadPairBasis\nmean: 8-element Vector{Float64}:\n  0.0\n  0.0\n  1.4142135623730951\n -1.4142135623730951\n  0.0\n  0.0\n  1.4142135623730951\n -1.4142135623730951\ncovariance: 8×8 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0\n\njulia> gd = Generaldyne(state, coh ⊗ vac ⊗ coh, [1, 3, 4])\nGeneraldyne on indices [1, 3, 4]\nsystem: GaussianState for 4 modes.\n (xType: Vector{Float64} | vType: Matrix{Float64})\noutcome: GaussianState for 3 modes.\n (xType: Vector{Float64} | vType: Matrix{Float64})\n\njulia> prob(gd)\n0.029788549650438086\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.ptrace-Union{Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, GaussianState, N}} where {Tm, Tc, N<:Int64}","page":"API","title":"Gabs.ptrace","text":"ptrace([Tm=Vector{Float64}, Tc=Matrix{Float64},] state::GaussianState, idx<:Int)\nptrace([Tm=Vector{Float64}, Tc=Matrix{Float64},] state::GaussianState, indices<:AbstractVector)\n\nPartial trace of a Gaussian state over a subsystem indicated by idx, or multiple subsystems indicated by indices.\n\nExample\n\njulia> basis = QuadPairBasis(1);\n\njulia> state = coherentstate(basis, 1.0+im) ⊗ thermalstate(basis, 2) ⊗ squeezedstate(basis, 3.0, pi/4)\nGaussianState for 3 modes.\n  symplectic basis: QuadPairBasis\nmean: 6-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 6×6 Matrix{Float64}:\n 1.0  0.0  0.0  0.0   0.0       0.0\n 0.0  1.0  0.0  0.0   0.0       0.0\n 0.0  0.0  2.5  0.0   0.0       0.0\n 0.0  0.0  0.0  2.5   0.0       0.0\n 0.0  0.0  0.0  0.0  29.5414   71.3164\n 0.0  0.0  0.0  0.0  71.3164  172.174\n\njulia> ptrace(state, 2)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 2.5  0.0\n 0.0  2.5\n\njulia> ptrace(state, [1, 3])\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n 1.0  0.0   0.0       0.0\n 0.0  1.0   0.0       0.0\n 0.0  0.0  29.5414   71.3164\n 0.0  0.0  71.3164  172.174\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.purity-Tuple{GaussianState}","page":"API","title":"Gabs.purity","text":"purity(state::GaussianState)\n\nCalculate the purity of a Gaussian state, defined by 1/sqrt(det(V)).\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.randchannel-Union{Tuple{N}, Tuple{Tt}, Tuple{Td}, Tuple{Type{Td}, Type{Tt}, Gabs.SymplecticBasis{N}}} where {Td, Tt, N<:Int64}","page":"API","title":"Gabs.randchannel","text":"randchannel([Td=Vector{Float64}, Tt=Matrix{Float64},] basis::SymplecticBasis)\n\nCalculate a random Gaussian channel in symplectic representation defined by basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.randstate-Union{Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}}} where {Tm, Tc, N<:Int64}","page":"API","title":"Gabs.randstate","text":"randstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis; pure=false)\n\nCalculate a random Gaussian state in symplectic representation defined by basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.randsymplectic-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Gabs.SymplecticBasis{N}}} where {T, N<:Int64}","page":"API","title":"Gabs.randsymplectic","text":"randsymplectic([T=Matrix{Float64},] basis::SymplecticBasis, passive=false)\n\nCalculate a random symplectic matrix in symplectic representation defined by basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.randunitary-Union{Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}}} where {Td, Ts, N<:Int64}","page":"API","title":"Gabs.randunitary","text":"randunitary([Td=Vector{Float64}, Ts=Matrix{Float64},] basis::SymplecticBasis; passive=false)\n\nCalculate a random Gaussian unitary operator in symplectic representation defined by basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.squeeze-Union{Tuple{R}, Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}, R, R}} where {Td, Ts, N<:Int64, R}","page":"API","title":"Gabs.squeeze","text":"squeeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real)\nsqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes the vacuum state into a squeezed state, known as the squeezing operator. The symplectic representation is given by basis. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a squeezing operator\n\nA squeeze operator S(r theta) is defined by the operation S(r theta)0rangle = r thetarangle, where r and theta are the real amplitude and phase parameters, respectively. The operator  S(r theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = cosh(r)mathbfI - sinh(r)mathbfR(theta)\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> squeeze(QuadPairBasis(1), 0.25, pi/4)\nGaussianUnitary for 1 mode.\n  symplectic basis: QuadPairBasis\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n  0.852789  -0.178624\n -0.178624   1.21004\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.squeezedstate-Union{Tuple{R}, Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}, R, R}} where {Tm, Tc, N<:Int64, R}","page":"API","title":"Gabs.squeezedstate","text":"squeezedstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, r<:Real, theta<:Real)\n\nGaussian state with quantum uncertainty in its phase and amplitude, known as the squeezed state. The symplectic representation is defined by basis. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of a squeezed state\n\nA squeezed state r thetarangle, where r is the amplitude squeezing parameter and theta is the phase squeezing parameter, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0\nquad mathbfV = frac12left(cosh(2r)mathbfI - sinh(2r)mathbfR(theta)right)\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> squeezedstate(QuadPairBasis(1), 0.5, pi/4)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 0.356044  0.415496\n 0.415496  1.18704\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.symplecticform-Union{Tuple{QuadPairBasis{N}}, Tuple{N}} where N<:Int64","page":"API","title":"Gabs.symplecticform","text":"symplecticform([T = Matrix{Float64},] basis::SymplecticBasis)\n\nCompute the symplectic form matrix of size 2N x 2N corresponding to basis.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.sympspectrum-Tuple{GaussianState}","page":"API","title":"Gabs.sympspectrum","text":"sympspectrum(state::GaussianState)\n\nCompute the symplectic spectrum of a Gaussian state.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.thermalstate-Union{Tuple{P}, Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}, P}} where {Tm, Tc, N<:Int64, P}","page":"API","title":"Gabs.thermalstate","text":"thermalstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] basis::SymplecticBasis, photons<:Int)\n\nGaussian state at thermal equilibrium, known as the thermal state. The symplectic representation is defined by basis. The mean photon number of the state is given by photons.\n\nMathematical description of a thermal state\n\nA thermal state barnrangle, where barn is the mean number of photons, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0 quad mathbfV = left(barn + frac12right)mathbfI\n\nExample\n\njulia> thermalstate(QuadPairBasis(1), 4)\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 4.5  0.0\n 0.0  4.5\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.twosqueeze-Union{Tuple{R}, Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, Gabs.SymplecticBasis{N}, R, R}} where {Td, Ts, N<:Int64, R}","page":"API","title":"Gabs.twosqueeze","text":"twosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real)\ntwosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], basis::SymplecticBasis, r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes a two-mode vacuum state into a two-mode squeezed state, known as the two-mode squeezing operator. The symplectic representation is given by basis. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a two-mode squeezing operator\n\nA two-mode squeeze operator S_2(r theta) is defined by the operation S_2(r theta)0rangle = r thetarangle, where r and theta are the real amplitude and phase parameters, respectively. The operator  S_2(r theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                    cosh(r)mathbfI  -sinh(r)mathbfR(theta) \n                    -sinh(r)mathbfR(theta)  cosh(r)mathbfI \n                    endpmatrix\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> twosqueeze(QuadPairBasis(2), 0.25, pi/4)\nGaussianUnitary for 2 modes.\n  symplectic basis: QuadPairBasis\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  1.03141    0.0       -0.178624  -0.178624\n  0.0        1.03141   -0.178624   0.178624\n -0.178624  -0.178624   1.03141    0.0\n -0.178624   0.178624   0.0        1.03141\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.vacuumstate-Union{Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, Gabs.SymplecticBasis{N}}} where {Tm, Tc, N<:Int64}","page":"API","title":"Gabs.vacuumstate","text":"vacuumstate([Tm=Vector{Float64}, Tc=Matrix{Float64}], basis::SymplecticBasis)\n\nGaussian state with zero photons, known as the vacuum state. The symplectic representation is defined by basis.\n\nMathematical description of a vacuum state\n\nA vacuum state 0rangle is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0 quad mathbfV = mathbfI\n\nExample\n\njulia> vacuumstate(QuadPairBasis(1))\nGaussianState for 1 mode.\n  symplectic basis: QuadPairBasis\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.wigner-Union{Tuple{T}, Tuple{GaussianState, T}} where T","page":"API","title":"Gabs.wigner","text":"wigner(state::GaussianState, x)\n\nCompute the Wigner function of an N-mode Gaussian state at x, a vector of size 2N.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.wignerchar-Union{Tuple{T}, Tuple{GaussianState, T}} where T","page":"API","title":"Gabs.wignerchar","text":"wignerchar(state::GaussianState, xi)\n\nCompute the Wigner characteristic function of an N-mode Gaussian state at xi, a vector of size 2N.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.directsum-Union{Tuple{R}, Tuple{R, R}} where R<:Gabs.SymplecticBasis","page":"API","title":"QuantumInterface.directsum","text":"directsum(basis1::SymplecticBasis, basis2::SymplecticBasis)\n\nCompute the direct sum of symplectic bases.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Union{Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, GaussianState, GaussianState}} where {Tm, Tc}","page":"API","title":"QuantumInterface.tensor","text":"tensor(state1::GaussianState, state2::GaussianState)\n\ntensor product of Gaussian states, which can also be called with ⊗.\n\nExample\n\njulia> basis = QuadPairBasis(1);\n\njulia> coherentstate(basis, 1.0+im) ⊗ thermalstate(basis, 2)\nGaussianState for 2 modes.\n  symplectic basis: QuadPairBasis\nmean: 4-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  2.5  0.0\n 0.0  0.0  0.0  2.5\n\n\n\n\n\n","category":"method"}]
}
