var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"DocTestSetup = quote\n    using Gabs\nend","category":"page"},{"location":"tutorials/#Visualizations","page":"Tutorials","title":"Visualizations","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Quasiprobability distributions of Gaussian states can be visualized with Makie.jl. Gabs.jl currently has support for the following distributions, which can be called with the keyword argument dist:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"wigner\nwignerchar","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Below is a code example that plots the wigner distribution of a vacuum state:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Gabs, CairoMakie\nstate = vacuumstate()\nq, p = collect(-5.0:0.5:5.0), collect(-5.0:0.5:5.0) # phase space coordinates\nheatmap(q, p, state, dist = :wigner)","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Of course, more plotting sugar can be added to this example with internal Makie attributes:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"using Gabs, CairoMakie\nstate = vacuumstate()\nq, p = collect(-5.0:0.5:5.0), collect(-5.0:0.5:5.0) # phase space coordinates\nfig = Figure(fontsize=15, size = (375, 300), fonts = (; regular=\"CMU Serif\"))\nax = Axis(fig[1,1], xlabel = L\"q\", ylabel = L\"p\")\nhm = heatmap!(ax, q, p, state, dist = :wigner, colormap = :heat)\nColorbar(fig[1,2], hm)\nfig","category":"page"},{"location":"tutorials/#Using-Custom-Arrays","page":"Tutorials","title":"Using Custom Arrays","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Types such as GaussianState, GaussianUnitary, and GaussianChannel are agnostic array wrappers, so they can hold any custom array that exists in the Julia ecosystem. Operations in Gabs.jl preserve these custom array types, provided they follow the AbstractArray interface.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Let's explore this feature in detail, using StaticArrays.jl and SparseArrays.jl as a case study. To create a coherent state that wraps around pure Julia arrays, the function coherentstate can be called with a single complex argument:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"julia> coherentstate(1.0-im)\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n  1.4142135623730951\n -1.4142135623730951\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Here, a GaussianState object containing a Vector{Float64} of size two (mean vector) and a Matrix{Float64} of size two by two (covariance matrix) was initialized. If we want to potentially optimize and boost the performance of our code, then one approach would be to wrap our GaussianState around different array types, for instance, an SVector from StaticArrays.jl or a SparseVector from SparseArrays.jl. Any defined method in Gabs.jl that (i) creates a custom type or (ii) transforms a custom type can specify an array type in its first (and second) arguments. Let's see an example with StaticArrays.jl:","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"julia> using StaticArrays\n\njulia> state = coherentstate(SVector{2}, SMatrix{2,2}, 1.0-im)\nGaussianState for 1 mode.\nmean: 2-element SVector{2, Float64} with indices SOneTo(2):\n  1.4142135623730951\n -1.4142135623730951\ncovariance: 2×2 SMatrix{2, 2, Float64, 4} with indices SOneTo(2)×SOneTo(2):\n 1.0  0.0\n 0.0  1.0\n\njulia> tp = state ⊗ state\nGaussianState for 2 modes.\nmean: 4-element SVector{4, Float64} with indices SOneTo(4):\n  1.4142135623730951\n -1.4142135623730951\n  1.4142135623730951\n -1.4142135623730951\ncovariance: 4×4 SMatrix{4, 4, Float64, 16} with indices SOneTo(4)×SOneTo(4):\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n\njulia> using SparseArrays\n\njulia> ptrace(SparseVector, SparseMatrixCSC, tp, 1)\nGaussianState for 1 mode.\nmean: 2-element SparseVector{Float64, Int64} with 2 stored entries:\n  [1]  =  1.41421\n  [2]  =  -1.41421\ncovariance: 2×2 SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n 1.0   ⋅ \n  ⋅   1.0","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Importantly, methods that create or manipulate a Gaussian state, such as tensor and ptrace, preserve array types, but can also opt for a different array type.","category":"page"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"note: Note\nIf you have an array wrapper that initializes both vectors and matrices, then you can specify the array type with a single argument. For instance, to initialize a state that contains Arrays holding numbers of type Float32 rather than Float64, simply pass Array{Float32} to any relevant Gabs.jl method:julia> state = displace(Array{Float32}, 1.0-im)\nGaussianUnitary for 1 mode.\ndisplacement: 2-element Vector{Float32}:\n  1.4142135\n -1.4142135\nsymplectic: 2×2 Matrix{Float32}:\n 1.0  0.0\n 0.0  1.0","category":"page"},{"location":"tutorials/#GPU-Acceleration","page":"Tutorials","title":"GPU Acceleration","text":"","category":"section"},{"location":"tutorials/#Multithreading","page":"Tutorials","title":"Multithreading","text":"","category":"section"},{"location":"tutorials/#Benchmarking-and-Profiling","page":"Tutorials","title":"Benchmarking and Profiling","text":"","category":"section"},{"location":"intro/#intro","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"Gabs.jl is a numerical tooling package for simulating Gaussian quantum information. Gaussian states and operators have the convenient property that they can be characterized by low-dimensional matrices in the phase space representation. Thus, a large class of continuous variable quantum information can be efficiently simulated on a classical computer, lending to applications in quantum cryptography, quantum machine learning, integrated quantum photonics, and more. Gabs.jl provides a high-level Julia interface for performing such efficient simulations in a straightforward manner.","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"In the sections below, a getting started tutorial is provided to introduce the capabilities of Gabs.jl. The rest of the documentation is structured as follows:","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"Manual - an overview of the package types and inner-workings,\nTutorials - explanations for using particular features of the library,\nGaussian Zoos - a description of predefined Gaussian states and operators,\nAPI - the full API of the library,\nSuggested Readings and References - publications and learning resources on Gaussian quantum information.","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"note: Note\nThis documentation assumes familiarity with linear algebra and quantum information. Introductory books and tutorials for these topics are provided in the Suggested Readings and References page.","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"tip: Contributing\nAny contribution to Gabs.jl is welcome! Feature suggestions, pull requests, and bug reports can be submitted on Github. The maintainers of Gabs.jl subscribe to the Julia Community Standards.","category":"page"},{"location":"intro/#Installation","page":"Getting Started with Gabs","title":"Installation","text":"","category":"section"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"To install Gabs.jl, start Julia and run the following command:","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"using Pkg\nPkg.add(\"Gabs\")","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"To use the package, run the command","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"using Gabs","category":"page"},{"location":"intro/","page":"Getting Started with Gabs","title":"Getting Started with Gabs","text":"Now, the entire library is loaded into the current workspace, with access to its high-level interface and predefined objects.","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"DocTestSetup = quote\n    using Gabs\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Simply put, Gabs.jl is a package for creating and transforming Gaussian bosonic systems. This section discusses the \"lower level\" tools for simulating such phenomena, with mathematical explanations when appropriate. For comprehensive reviews of Gaussian quantum information, see the suggested readings page.","category":"page"},{"location":"manual/#Gaussian-States","page":"Manual","title":"Gaussian States","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The star of this package is the GaussianState type, which allows us to initialize and manipulate a phase space description of an arbitrary Gaussian state.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"GaussianState","category":"page"},{"location":"manual/#Gabs.GaussianState-manual","page":"Manual","title":"Gabs.GaussianState","text":"Defines a Gaussian state for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nmean: The mean vector of length 2N.\ncovar: The covariance matrix of size 2N x 2N.\nnmodes: The number of modes N of the Gaussian state.\n\nMathematical description of a Gaussian state\n\nAn N-mode Gaussian state, hatrho(mathbfbarx mathbfV), is a density operator characterized by two statistical moments: a mean vector mathbfbarx of length 2N and covariance matrix mathbfV of size 2Ntimes 2N. By definition, the Wigner representation of a Gaussian state is a Gaussian function.\n\nExample\n\njulia> coherentstate(1.0+im)\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"Functions to create instances of elementary Gaussian states are provided as part of the package API.  Listed below are supported predefined Gaussian states:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"vacuumstate\nthermalstate\ncoherentstate\nsqueezedstate\neprstate","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Detailed discussions and mathematical descriptions for each of these states are given in the Gaussian Zoos page.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If we were operating in the state (Fock) space, and wanted to describe multi-mode Gaussian states, we would take the tensor product of multiple density operators. That method, however, is quite computationally expensive and requires a finite truncation of the Fock basis. To create such state vector simulations, we recommend using the QuantumOptics.jl library. For our purposes in the phase space, we can manually create multi-mode Gaussian systems with a tensor product, which can be called with either tensor or ⊗, the Kronecker product symbol which can be typed in the Julia REPL as \\otimes<TAB>. Take the following example, where we produce a 3-mode Gaussian state that consists of a coherent state, vacuumstate, and squeezed state:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"julia> coherentstate(-1.0) ⊗ vacuumstate() ⊗ squeezedstate(0.25, pi/4)\nGaussianState for 3 modes.\nmean: 6-element Vector{Float64}:\n -1.4142135623730951\n  0.0\n  0.0\n  0.0\n  0.0\n  0.0\ncovariance: 6×6 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  0.0       0.0\n 0.0  1.0  0.0  0.0  0.0       0.0\n 0.0  0.0  1.0  0.0  0.0       0.0\n 0.0  0.0  0.0  1.0  0.0       0.0\n 0.0  0.0  0.0  0.0  0.379578  0.184235\n 0.0  0.0  0.0  0.0  0.184235  0.748048","category":"page"},{"location":"manual/#Gaussian-Operators","page":"Manual","title":"Gaussian Operators","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To transform Gaussian states into Gaussian states, we need Gaussian maps. There are various ways to construct Gaussian transformations, which we will discuss in this section.","category":"page"},{"location":"manual/#Gaussian-Unitaries","page":"Manual","title":"Gaussian Unitaries","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Let's begin with the simplest Gaussian transformation, a unitary transformation, which can be created with the GaussianUnitary type:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"GaussianUnitary","category":"page"},{"location":"manual/#Gabs.GaussianUnitary-manual","page":"Manual","title":"Gabs.GaussianUnitary","text":"Defines a Gaussian unitary for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\ndisp: The displacement vector of length 2N.\nsymplectic: The symplectic matrix of size 2N x 2N.\nnmodes: The number of modes N for the Gaussian unitary.\n\nMathematical description of a Gaussian unitary\n\nAn N-mode Gaussian unitary, U(mathbfd mathbfS), is a unitary operator characterized by a displacement vector mathbfd of length 2N and symplectic matrix mathbfS of size 2Ntimes 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian unitary transformation on a Gaussian state hatrho(mathbfbarx mathbfV) is described by its maps on the statistical moments of the Gaussian state:\n\nmathbfbarx to mathbfS mathbfbarx + mathbfd quad\nmathbfV to mathbfS mathbfV mathbfS^textT\n\nExample\n\njulia> displace(1.0+im)\nGaussianUnitary for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"This is a rather clean way to characterize a large group of Gaussian transformations on an N-mode Gaussian bosonic system. As long as we have a displacement vector of size 2N and symplectic matrix of size 2N x 2N, we can create a Gaussian transformation. ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nA matrix mathbfS of size 2Ntimes 2N is symplectic when it satisfies the following relation:mathbfS mathbfOmega mathbfS^textT = mathbfOmega qquad mathbfOmega equiv bigoplus_i=1^N beginpmatrix 0  -1  -1  0 endpmatrix","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"This library has a number of predefined Gaussian unitaries, which are listed below:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"displace\nsqueeze\ntwosqueeze\nphaseshift\nbeamsplitter","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Detailed discussions and mathematical descriptions for each of these unitaries are given in the Gaussian Zoos page.","category":"page"},{"location":"manual/#Gaussian-Channels","page":"Manual","title":"Gaussian Channels","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Noisy bosonic channels are an important model for describing the interaction between a Gaussian state and its environment. Similar to Gaussian unitaries, Gaussian channels are linear bosonic channels that map Gaussian states to Gaussian states. Such objects can be created with the GaussianChannel type:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"GaussianChannel","category":"page"},{"location":"manual/#Gabs.GaussianChannel-manual","page":"Manual","title":"Gabs.GaussianChannel","text":"Defines a Gaussian channel for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\ndisp: The displacement vector of length 2N.\ntransform: The transformation matrix of size 2N x 2N.\nnoise: The noise matrix of size 2N x 2N.\nnmodes: The number of modes N for the Gaussian channel.\n\nMathematical description of a Gaussian channel\n\nAn N-mode Gaussian channel, G(mathbfd mathbfT mathbfN), is an operator characterized by a displacement vector mathbfd of length 2N, as well as a transformation matrix mathbfT and noise matrix mathbfN of size 2Ntimes 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian channel action on a Gaussian state hatrho(mathbfbarx mathbfV) is described by its maps on the statistical moments of the Gaussian state:\n\nmathbfbarx to mathbfS mathbfbarx + mathbfd quad\nmathbfV to mathbfT mathbfV mathbfT^textT + mathbfN\n\nExample\n\njulia> noise = [1.0 -3.0; 4.0 2.0];\n\njulia> displace(1.0+im, noise)\nGaussianChannel for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ntransform: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\nnoise: 2×2 Matrix{Float64}:\n 1.0  -3.0\n 4.0   2.0\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"Listed below are a list of predefined Gaussian channels supported by Gabs.jl:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"attenuator\namplifier","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"note: Note\nWhen its noise matrix mathbfN = mathbf0 and transform operator mathbfT is a symplectic matrix, a Gaussian channel is a unitary operator. Any predefined Gaussian unitary method can be called with an additional noise matrix to create a GaussianChannel object. For instance, a noisy displacement operator can be called with displace as follows:julia> noise = [1.0 -2.0; 4.0 -3.0];\n\njulia> displace(1.0-im, noise)\nGaussianChannel for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n  1.4142135623730951\n -1.4142135623730951\ntransform: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\nnoise: 2×2 Matrix{Float64}:\n 1.0  -2.0\n 4.0  -3.0","category":"page"},{"location":"zoos/#Gaussian-Zoos","page":"Gaussian Zoos","title":"Gaussian Zoos","text":"","category":"section"},{"location":"zoos/#State-Zoo","page":"Gaussian Zoos","title":"State Zoo","text":"","category":"section"},{"location":"zoos/","page":"Gaussian Zoos","title":"Gaussian Zoos","text":"vacuumstate\nthermalstate\ncoherentstate\nsqueezedstate\neprstate","category":"page"},{"location":"zoos/#Gabs.vacuumstate-zoos","page":"Gaussian Zoos","title":"Gabs.vacuumstate","text":"vacuumstate([Tm=Vector{Float64}, Tc=Matrix{Float64}])\n\nGaussian state with zero photons, known as the vacuum state.\n\nMathematical description of a vacuum state\n\nA vacuum state 0rangle is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0 quad mathbfV = mathbfI\n\nExample\n\njulia> vacuumstate()\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.thermalstate-zoos","page":"Gaussian Zoos","title":"Gabs.thermalstate","text":"thermalstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] photons<:Int)\n\nGaussian state at thermal equilibrium, known as the thermal state. The mean photon number of the state is given by photons.\n\nMathematical description of a thermal state\n\nA thermal state barnrangle, where barn is the mean number of photons, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0 quad mathbfV = left(barn + frac12right)mathbfI\n\nExample\n\njulia> thermalstate(4)\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 4.5  0.0\n 0.0  4.5\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.coherentstate-zoos","page":"Gaussian Zoos","title":"Gabs.coherentstate","text":"coherentstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] alpha<:Number)\n\nGaussian state that is the quantum analogue of a monochromatic electromagnetic field, known as the coherent state. The complex amplitude of the state is given by alpha.\n\nMathematical description of a coherent state\n\nA coherent state alpharangle, where alpha is the complex amplitude, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = sqrt2left(textRe(alpha) textIm(alpha)right)^textT\nquad mathbfV = mathbfI\n\nExample\n\njulia> coherentstate(1.0+im)\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.squeezedstate-zoos","page":"Gaussian Zoos","title":"Gabs.squeezedstate","text":"squeezedstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] r<:Real, theta<:Real)\n\nGaussian state with quantum uncertainty in its phase and amplitude, known as the squeezed state. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of a squeezed state\n\nA squeezed state r thetarangle, where r is the amplitude squeezing parameter and theta is the phase squeezing parameter, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0\nquad mathbfV = frac12left(cosh(2r)mathbfI - sinh(2r)mathbfR(theta)right)\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> squeezedstate(0.5, pi/4)\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 0.356044  0.415496\n 0.415496  1.18704\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.eprstate-zoos","page":"Gaussian Zoos","title":"Gabs.eprstate","text":"eprstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] r<:Real, theta<:Real)\n\nGaussian state that is a two-mode squeezed state, known as the Einstein-Podolski-Rosen (EPR) state. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of an EPR state\n\nAn EPR state r thetarangle_textEPR, where r is the amplitude squeezing parameter and theta is the phase squeezing parameter, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0\nquad mathbfV = frac12beginpmatrix\n                                    cosh(2r)mathbfI  -sinh(2r)mathbfR(theta) \n                                    -sinh(2r)mathbfR(theta)  cosh(2r)mathbfI \n                                    endpmatrix\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> eprstate(0.5, pi/4)\nGaussianState for 2 modes.\nmean: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n 0.77154    0.0       0.415496   0.415496\n 0.0        0.77154   0.415496  -0.415496\n 0.415496   0.415496  0.77154    0.0\n 0.415496  -0.415496  0.0        0.77154\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Operator-Zoo","page":"Gaussian Zoos","title":"Operator Zoo","text":"","category":"section"},{"location":"zoos/","page":"Gaussian Zoos","title":"Gaussian Zoos","text":"displace\nsqueeze\ntwosqueeze\nphaseshift\nbeamsplitter\nattenuator\namplifier","category":"page"},{"location":"zoos/#Gabs.displace-zoos","page":"Gaussian Zoos","title":"Gabs.displace","text":"displace([Tm=Vector{Float64}, Ts=Matrix{Float64}], alpha<:Number)\ndisplace([Tm=Vector{Float64}, Ts=Matrix{Float64}], alpha<:Number, noise::Ts)\n\nGaussian operator that displaces the vacuum state into a coherent state, known as the displacement operator. The complex amplitude is given by alpha. Noise can be added to the operation with noise.\n\nMathematical description of a displacement operator\n\nA displacement operator D(alpha) is defined by the operation D(alpha)0rangle = alpharangle, where alpha is a complex amplitude. The operator D(alpha) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = sqrt2left(textRe(alpha) textIm(alpha)right)^textT\nquad mathbfS = mathbfI\n\nExample\n\njulia> displace(1.0+im)\nGaussianUnitary for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.squeeze-zoos","page":"Gaussian Zoos","title":"Gabs.squeeze","text":"squeeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], r<:Real, theta<:Real)\nsqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes the vacuum state into a squeezed state, known as the squeezing operator. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a squeezing operator\n\nA squeeze operator S(r theta) is defined by the operation S(r theta)0rangle = r thetarangle, where r and theta are the real amplitude and phase parameters, respectively. The operator  S(r theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = cosh(r)mathbfI - sinh(r)mathbfR(theta)\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> squeeze(0.25, pi/4)\nGaussianUnitary for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n 0.215425   0.0451226\n 0.0451226  0.30567\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.twosqueeze-zoos","page":"Gaussian Zoos","title":"Gabs.twosqueeze","text":"twosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], r<:Real, theta<:Real)\ntwosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes a two-mode vacuum state into a two-mode squeezed state, known as the two-mode squeezing operator. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a two-mode squeezing operator\n\nA two-mode squeeze operator S_2(r theta) is defined by the operation S_2(r theta)0rangle = r thetarangle, where r and theta are the real amplitude and phase parameters, respectively. The operator  S_2(r theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                    cosh(r)mathbfI  -sinh(r)mathbfR(theta) \n                    -sinh(r)mathbfR(theta)  cosh(r)mathbfI \n                    endpmatrix\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> twosqueeze(0.25, pi/4)\nGaussianUnitary for 2 modes.\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  1.03141    0.0       -0.178624  -0.178624\n  0.0        1.03141   -0.178624   0.178624\n -0.178624  -0.178624   1.03141    0.0\n -0.178624   0.178624   0.0        1.03141\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.phaseshift-zoos","page":"Gaussian Zoos","title":"Gabs.phaseshift","text":"phaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], theta<:Real)\nphaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], theta<:Real, noise::Ts)\n\nGaussian operator that rotates the phase of a given Gaussian mode by theta, as the phase shift operator. Noise can be added to the operation with noise.\n\nMathematical description of a phase shift operator\n\nA phase shift operator U(theta) is defined by the operation U(Theta) = exp(-ithetahata^daggerhata), where theta is the phase parameter, and hata^dagger and hata are the raising and lowering operators, respectively. The operator  U(theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                        cos(theta)  sin(theta) \n                        -sin(theta)  cos(theta) \n                     endpmatrix\n\nExample\n\njulia> phaseshift(3pi/4)\nGaussianUnitary for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n -0.707107   0.707107\n -0.707107  -0.707107\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.beamsplitter-zoos","page":"Gaussian Zoos","title":"Gabs.beamsplitter","text":"beamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], transmit<:Real)\nbeamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], transmit<:Real, noise::Ts)\n\nGaussian operator that serves as the beam splitter transformation of a two-mode Gaussian state, known as the beam splitter operator. The transmittivity of the operator is given by transmit. Noise can be added to the operation with noise.\n\nMathematical description of a beam splitter operator\n\nA beam splitter operator B(tau) is defined by the operation B(theta) = explefttheta(hata^daggerhatb - hatahatb^dagger)right, where theta is defined by tau = cos^2theta, and hata and hatb are the annihilation operators of the two modes, respectively. The operator  B(tau) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                        sqrttaumathbfI  sqrt1-taumathbfI \n                        -sqrt1-taumathbfI  sqrttaumathbfI \n                     endpmatrix\n\nExample\n\njulia> beamsplitter(0.75)\nGaussianUnitary for 2 modes.\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  0.866025   0.0       0.5       0.0\n  0.0        0.866025  0.0       0.5\n -0.5        0.0       0.866025  0.0\n  0.0       -0.5       0.0       0.866025\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.attenuator-zoos","page":"Gaussian Zoos","title":"Gabs.attenuator","text":"attenuator([Td=Vector{Float64}, Tt=Matrix{Float64},] theta<:Real, n<:Int)\n\nGaussian channel describing the coupling of an input single mode Gaussian state and its environment via a beam splitter operation. The channel is paramatrized by beam splitter rotation angle theta and thermal noise n.\n\nMathematical description of an attenuator channel\n\nAn attenuator channel, mathcalE_theta^n_textth, where theta is the beam splitter rotation parameter and n_textth geq 1 is the thermal noise parameter, is characterized by the displacement vector mathbfd, transformation matrix mathbfT, and noise matrix mathbfN, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfT = costhetamathbfI\nqquad mathbfN = (sintheta)^2 n_textth mathbfI\n\nExample\n\njulia> attenuator(pi/6, 3)\nGaussianChannel for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 0.866025  0.0\n 0.0       0.866025\nnoise: 2×2 Matrix{Float64}:\n 0.75  0.0\n 0.0   0.75\n\n\n\n\n\n","category":"function"},{"location":"zoos/#Gabs.amplifier-zoos","page":"Gaussian Zoos","title":"Gabs.amplifier","text":"amplifier([Td=Vector{Float64}, Tt=Matrix{Float64},] r<:Real, n<:Int)\n\nGaussian channel describing the interaction of an input single mode Gaussian state and its environment via a two-mode squeezing operation. The channel is paramatrized by squeezing amplitude parameter r and thermal noise n.\n\nMathematical description of an amplifier channel\n\nAn amplifier channel, mathcalA_theta^n_textth, where r is the squeezing amplitude parameter and n_textth geq 1 is the thermal noise parameter, is characterized by the displacement vector mathbfd, transformation matrix mathbfT, and noise matrix mathbfN, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfT = cosh rmathbfI\nqquad mathbfN = (sinh r)^2 n_textth mathbfI\n\nExample\n\njulia> amplifier(2.0, 3)\nGaussianChannel for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 3.7622  0.0\n 0.0     3.7622\nnoise: 2×2 Matrix{Float64}:\n 39.4623   0.0\n  0.0     39.4623\n\n\n\n\n\n","category":"function"},{"location":"bibliography/#References","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"","category":"section"},{"location":"bibliography/#Tutorials-on-Gaussian-Quantum-Information","page":"Suggested Readings and References","title":"Tutorials on Gaussian Quantum Information","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Adesso, G.; Ragy, S. and Lee, A. R. (2014). Continuous Variable Quantum Information: Gaussian States and Beyond. Open Systems & Information Dynamics 21, 1440001.\n\n\n\nOlivares, S. (2011). Quantum optics in the phase space. The European Physical Journal Special Topics 203, 3–24.\n\n\n\nWang, X.-B.; Hiroshima, T.; Tomita, A. and Hayashi, M. (2007). Quantum information with Gaussian states. Physics Reports 448, 1–111.\n\n\n\nWeedbrook, C.; Pirandola, S.; Garcı́a-Patrón, R.; Cerf, N. J.; Ralph, T. C.; Shapiro, J. H. and Lloyd, S. (2012). Gaussian quantum information. Rev. Mod. Phys. 84, 621–669.\n\n\n\n","category":"page"},{"location":"bibliography/#Tutorials-and-Books-on-Quantum-Continuous-Variables","page":"Suggested Readings and References","title":"Tutorials and Books on Quantum Continuous Variables","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Braunstein, S. L. and van Loock, P. (2005). Quantum information with continuous variables. Rev. Mod. Phys. 77, 513–577.\n\n\n\nCerf, N. J.; Leuchs, G. and Polzik, E. S. (2007). Quantum Information with Continuous Variables of Atoms and Light (Imperial College Press).\n\n\n\nSerafini, A. (2023). Quantum Continuous Variables: A Primer of Theoretical Methods (CRC Press).\n\n\n\nWalschaers, M. (2021). Non-Gaussian Quantum States and Where to Find Them. PRX Quantum 2, 030204.\n\n\n\n","category":"page"},{"location":"bibliography/#Technical-Reviews-on-Quantum-Continuous-Variables","page":"Suggested Readings and References","title":"Technical Reviews on Quantum Continuous Variables","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Andersen, U.; Leuchs, G. and Silberhorn, C. (2010). Continuous-variable quantum information processing. Laser & Photonics Reviews 4, 337–354.\n\n\n\nCerf, N. J. and Grangier, P. (2007). From quantum cloning to quantum key distribution with continuous variables: a review (Invited). J. Opt. Soc. Am. B 24, 324–334.\n\n\n\nFukui, K. and Takeda, S. (2022). Building a large-scale quantum computer with continuous-variable optical technologies. Journal of Physics B: Atomic, Molecular and Optical Physics 55, 012001.\n\n\n\nGoldberg, A. Z.; Klimov, A. B.; Grassl, M.; Leuchs, G. and Sánchez-Soto, L. L. (2020). Extremal quantum states. AVS Quantum Science 2, 044701.\n\n\n\nJankowski, M.; Yanagimoto, R.; Ng, E.; Hamerly, R.; McKenna, T. P.; Mabuchi, H. and Fejer, M. M. (2024). Ultrafast second-order nonlinear photonics—from classical physics to non-Gaussian quantum dynamics: a tutorial. Adv. Opt. Photon. 16, 347–538.\n\n\n\nvan Loock, P. (2002). Quantum Communication with Continuous Variables. Fortschritte der Physik 50, 1177–1372.\n\n\n\nLvovsky, A. I. and Raymer, M. G. (2009). Continuous-variable optical quantum-state tomography. Rev. Mod. Phys. 81, 299–332.\n\n\n\nPirandola, S. and Mancini, S. (2006). Quantum teleportation with continuous variables: A survey. Laser Physics 16, 1418–1438.\n\n\n\n","category":"page"},{"location":"bibliography/#Publications-on-Gaussian-Quantum-Measurements","page":"Suggested Readings and References","title":"Publications on Gaussian Quantum Measurements","text":"","category":"section"},{"location":"bibliography/","page":"Suggested Readings and References","title":"Suggested Readings and References","text":"Cenni, M. F.; Lami, L.; Acín, A. and Mehboudi, M. (2022). Thermometry of Gaussian quantum systems using Gaussian measurements. Quantum 6, 743.\n\n\n\nKiukas, J. and Schultz, J. (2013). Informationally complete sets of Gaussian measurements. Journal of Physics A: Mathematical and Theoretical 46, 485303.\n\n\n\nMarco G. Genoni, L. L. and Serafini, A. (2016). Conditional and unconditional Gaussian quantum dynamics. Contemporary Physics 57, 331–349.\n\n\n\nZhang, J. (2018). Quantum measurement and preparation of Gaussian states. Ph.D. Thesis, Aarhus University.\n\n\n\n","category":"page"},{"location":"#Gabs.jl","page":"Gabs.jl","title":"Gabs.jl","text":"","category":"section"},{"location":"","page":"Gabs.jl","title":"Gabs.jl","text":"DocTestSetup = quote\n    using Gabs\nend","category":"page"},{"location":"","page":"Gabs.jl","title":"Gabs.jl","text":"A numerical package for simulating Gaussian quantum information in the phase space representation.","category":"page"},{"location":"","page":"Gabs.jl","title":"Gabs.jl","text":"Visit the getting started page for an introduction to Gabs.jl and its documentation.","category":"page"},{"location":"API/#Full-API","page":"API","title":"Full API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"<style>\n    .content table td {\n        padding-top: 0 !important;\n        padding-bottom: 0 !important;\n    }\n</style>","category":"page"},{"location":"API/#Autogenerated-API-list","page":"API","title":"Autogenerated API list","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [Gabs, QuantumInterface]\nPrivate = false","category":"page"},{"location":"API/#Gabs.GaussianChannel","page":"API","title":"Gabs.GaussianChannel","text":"Defines a Gaussian channel for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\ndisp: The displacement vector of length 2N.\ntransform: The transformation matrix of size 2N x 2N.\nnoise: The noise matrix of size 2N x 2N.\nnmodes: The number of modes N for the Gaussian channel.\n\nMathematical description of a Gaussian channel\n\nAn N-mode Gaussian channel, G(mathbfd mathbfT mathbfN), is an operator characterized by a displacement vector mathbfd of length 2N, as well as a transformation matrix mathbfT and noise matrix mathbfN of size 2Ntimes 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian channel action on a Gaussian state hatrho(mathbfbarx mathbfV) is described by its maps on the statistical moments of the Gaussian state:\n\nmathbfbarx to mathbfS mathbfbarx + mathbfd quad\nmathbfV to mathbfT mathbfV mathbfT^textT + mathbfN\n\nExample\n\njulia> noise = [1.0 -3.0; 4.0 2.0];\n\njulia> displace(1.0+im, noise)\nGaussianChannel for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ntransform: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\nnoise: 2×2 Matrix{Float64}:\n 1.0  -3.0\n 4.0   2.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.GaussianState","page":"API","title":"Gabs.GaussianState","text":"Defines a Gaussian state for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\nmean: The mean vector of length 2N.\ncovar: The covariance matrix of size 2N x 2N.\nnmodes: The number of modes N of the Gaussian state.\n\nMathematical description of a Gaussian state\n\nAn N-mode Gaussian state, hatrho(mathbfbarx mathbfV), is a density operator characterized by two statistical moments: a mean vector mathbfbarx of length 2N and covariance matrix mathbfV of size 2Ntimes 2N. By definition, the Wigner representation of a Gaussian state is a Gaussian function.\n\nExample\n\njulia> coherentstate(1.0+im)\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.GaussianUnitary","page":"API","title":"Gabs.GaussianUnitary","text":"Defines a Gaussian unitary for an N-mode bosonic system over a 2N-dimensional phase space.\n\nFields\n\ndisp: The displacement vector of length 2N.\nsymplectic: The symplectic matrix of size 2N x 2N.\nnmodes: The number of modes N for the Gaussian unitary.\n\nMathematical description of a Gaussian unitary\n\nAn N-mode Gaussian unitary, U(mathbfd mathbfS), is a unitary operator characterized by a displacement vector mathbfd of length 2N and symplectic matrix mathbfS of size 2Ntimes 2N, such that its action on a Gaussian state results in a Gaussian state. More specifically, a Gaussian unitary transformation on a Gaussian state hatrho(mathbfbarx mathbfV) is described by its maps on the statistical moments of the Gaussian state:\n\nmathbfbarx to mathbfS mathbfbarx + mathbfd quad\nmathbfV to mathbfS mathbfV mathbfS^textT\n\nExample\n\njulia> displace(1.0+im)\nGaussianUnitary for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"API/#Gabs.amplifier-Union{Tuple{N}, Tuple{R}, Tuple{Tt}, Tuple{Td}, Tuple{Type{Td}, Type{Tt}, R, N}} where {Td, Tt, R<:Real, N<:Int64}","page":"API","title":"Gabs.amplifier","text":"amplifier([Td=Vector{Float64}, Tt=Matrix{Float64},] r<:Real, n<:Int)\n\nGaussian channel describing the interaction of an input single mode Gaussian state and its environment via a two-mode squeezing operation. The channel is paramatrized by squeezing amplitude parameter r and thermal noise n.\n\nMathematical description of an amplifier channel\n\nAn amplifier channel, mathcalA_theta^n_textth, where r is the squeezing amplitude parameter and n_textth geq 1 is the thermal noise parameter, is characterized by the displacement vector mathbfd, transformation matrix mathbfT, and noise matrix mathbfN, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfT = cosh rmathbfI\nqquad mathbfN = (sinh r)^2 n_textth mathbfI\n\nExample\n\njulia> amplifier(2.0, 3)\nGaussianChannel for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 3.7622  0.0\n 0.0     3.7622\nnoise: 2×2 Matrix{Float64}:\n 39.4623   0.0\n  0.0     39.4623\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.attenuator-Union{Tuple{N}, Tuple{R}, Tuple{Tt}, Tuple{Td}, Tuple{Type{Td}, Type{Tt}, R, N}} where {Td, Tt, R<:Real, N<:Int64}","page":"API","title":"Gabs.attenuator","text":"attenuator([Td=Vector{Float64}, Tt=Matrix{Float64},] theta<:Real, n<:Int)\n\nGaussian channel describing the coupling of an input single mode Gaussian state and its environment via a beam splitter operation. The channel is paramatrized by beam splitter rotation angle theta and thermal noise n.\n\nMathematical description of an attenuator channel\n\nAn attenuator channel, mathcalE_theta^n_textth, where theta is the beam splitter rotation parameter and n_textth geq 1 is the thermal noise parameter, is characterized by the displacement vector mathbfd, transformation matrix mathbfT, and noise matrix mathbfN, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfT = costhetamathbfI\nqquad mathbfN = (sintheta)^2 n_textth mathbfI\n\nExample\n\njulia> attenuator(pi/6, 3)\nGaussianChannel for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\ntransform: 2×2 Matrix{Float64}:\n 0.866025  0.0\n 0.0       0.866025\nnoise: 2×2 Matrix{Float64}:\n 0.75  0.0\n 0.0   0.75\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.beamsplitter-Union{Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, N}} where {Td, Ts, N<:Real}","page":"API","title":"Gabs.beamsplitter","text":"beamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], transmit<:Real)\nbeamsplitter([Tm=Vector{Float64}, Ts=Matrix{Float64}], transmit<:Real, noise::Ts)\n\nGaussian operator that serves as the beam splitter transformation of a two-mode Gaussian state, known as the beam splitter operator. The transmittivity of the operator is given by transmit. Noise can be added to the operation with noise.\n\nMathematical description of a beam splitter operator\n\nA beam splitter operator B(tau) is defined by the operation B(theta) = explefttheta(hata^daggerhatb - hatahatb^dagger)right, where theta is defined by tau = cos^2theta, and hata and hatb are the annihilation operators of the two modes, respectively. The operator  B(tau) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                        sqrttaumathbfI  sqrt1-taumathbfI \n                        -sqrt1-taumathbfI  sqrttaumathbfI \n                     endpmatrix\n\nExample\n\njulia> beamsplitter(0.75)\nGaussianUnitary for 2 modes.\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  0.866025   0.0       0.5       0.0\n  0.0        0.866025  0.0       0.5\n -0.5        0.0       0.866025  0.0\n  0.0       -0.5       0.0       0.866025\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.coherentstate-Union{Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, N}} where {Tm, Tc, N<:Number}","page":"API","title":"Gabs.coherentstate","text":"coherentstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] alpha<:Number)\n\nGaussian state that is the quantum analogue of a monochromatic electromagnetic field, known as the coherent state. The complex amplitude of the state is given by alpha.\n\nMathematical description of a coherent state\n\nA coherent state alpharangle, where alpha is the complex amplitude, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = sqrt2left(textRe(alpha) textIm(alpha)right)^textT\nquad mathbfV = mathbfI\n\nExample\n\njulia> coherentstate(1.0+im)\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.displace-Union{Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, N}} where {Td, Ts, N<:Number}","page":"API","title":"Gabs.displace","text":"displace([Tm=Vector{Float64}, Ts=Matrix{Float64}], alpha<:Number)\ndisplace([Tm=Vector{Float64}, Ts=Matrix{Float64}], alpha<:Number, noise::Ts)\n\nGaussian operator that displaces the vacuum state into a coherent state, known as the displacement operator. The complex amplitude is given by alpha. Noise can be added to the operation with noise.\n\nMathematical description of a displacement operator\n\nA displacement operator D(alpha) is defined by the operation D(alpha)0rangle = alpharangle, where alpha is a complex amplitude. The operator D(alpha) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = sqrt2left(textRe(alpha) textIm(alpha)right)^textT\nquad mathbfS = mathbfI\n\nExample\n\njulia> displace(1.0+im)\nGaussianUnitary for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\nsymplectic: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.eprstate-Union{Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, N, N}} where {Tm, Tc, N<:Real}","page":"API","title":"Gabs.eprstate","text":"eprstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] r<:Real, theta<:Real)\n\nGaussian state that is a two-mode squeezed state, known as the Einstein-Podolski-Rosen (EPR) state. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of an EPR state\n\nAn EPR state r thetarangle_textEPR, where r is the amplitude squeezing parameter and theta is the phase squeezing parameter, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0\nquad mathbfV = frac12beginpmatrix\n                                    cosh(2r)mathbfI  -sinh(2r)mathbfR(theta) \n                                    -sinh(2r)mathbfR(theta)  cosh(2r)mathbfI \n                                    endpmatrix\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> eprstate(0.5, pi/4)\nGaussianState for 2 modes.\nmean: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n 0.77154    0.0       0.415496   0.415496\n 0.0        0.77154   0.415496  -0.415496\n 0.415496   0.415496  0.77154    0.0\n 0.415496  -0.415496  0.0        0.77154\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.phaseshift-Union{Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, N}} where {Td, Ts, N<:Real}","page":"API","title":"Gabs.phaseshift","text":"phaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], theta<:Real)\nphaseshift([Tm=Vector{Float64}, Ts=Matrix{Float64}], theta<:Real, noise::Ts)\n\nGaussian operator that rotates the phase of a given Gaussian mode by theta, as the phase shift operator. Noise can be added to the operation with noise.\n\nMathematical description of a phase shift operator\n\nA phase shift operator U(theta) is defined by the operation U(Theta) = exp(-ithetahata^daggerhata), where theta is the phase parameter, and hata^dagger and hata are the raising and lowering operators, respectively. The operator  U(theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                        cos(theta)  sin(theta) \n                        -sin(theta)  cos(theta) \n                     endpmatrix\n\nExample\n\njulia> phaseshift(3pi/4)\nGaussianUnitary for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n -0.707107   0.707107\n -0.707107  -0.707107\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.ptrace-Union{Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, GaussianState, N}} where {Tm, Tc, N<:Int64}","page":"API","title":"Gabs.ptrace","text":"ptrace([Tm=Vector{Float64}, Tc=Matrix{Float64},] state::GaussianState, idx<:Int)\nptrace([Tm=Vector{Float64}, Tc=Matrix{Float64},] state::GaussianState, indices<:AbstractVector)\n\nPartial trace of a Gaussian state over a subsytem indicated by idx, or multiple subsystems indicated by indices.\n\nExample\n\njulia> state = coherentstate(1.0+im) ⊗ thermalstate(2) ⊗ squeezedstate(3.0, pi/4)\nGaussianState for 3 modes.\nmean: 6-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\n 0.0\n 0.0\n 0.0\n 0.0\ncovariance: 6×6 Matrix{Float64}:\n 1.0  0.0  0.0  0.0   0.0       0.0\n 0.0  1.0  0.0  0.0   0.0       0.0\n 0.0  0.0  2.5  0.0   0.0       0.0\n 0.0  0.0  0.0  2.5   0.0       0.0\n 0.0  0.0  0.0  0.0  29.5414   71.3164\n 0.0  0.0  0.0  0.0  71.3164  172.174\n\njulia> ptrace(state, 2)\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 2.5  0.0\n 0.0  2.5\n\njulia> ptrace(state, [1, 3])\nGaussianState for 2 modes.\nmean: 4-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n 1.0  0.0   0.0       0.0\n 0.0  1.0   0.0       0.0\n 0.0  0.0  29.5414   71.3164\n 0.0  0.0  71.3164  172.174\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.squeeze-Union{Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, N, N}} where {Td, Ts, N<:Real}","page":"API","title":"Gabs.squeeze","text":"squeeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], r<:Real, theta<:Real)\nsqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes the vacuum state into a squeezed state, known as the squeezing operator. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a squeezing operator\n\nA squeeze operator S(r theta) is defined by the operation S(r theta)0rangle = r thetarangle, where r and theta are the real amplitude and phase parameters, respectively. The operator  S(r theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = cosh(r)mathbfI - sinh(r)mathbfR(theta)\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> squeeze(0.25, pi/4)\nGaussianUnitary for 1 mode.\ndisplacement: 2-element Vector{Float64}:\n 0.0\n 0.0\nsymplectic: 2×2 Matrix{Float64}:\n 0.215425   0.0451226\n 0.0451226  0.30567\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.squeezedstate-Union{Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, N, N}} where {Tm, Tc, N<:Real}","page":"API","title":"Gabs.squeezedstate","text":"squeezedstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] r<:Real, theta<:Real)\n\nGaussian state with quantum uncertainty in its phase and amplitude, known as the squeezed state. The amplitude and phase squeezing parameters are given by r and theta, respectively.\n\nMathematical description of a squeezed state\n\nA squeezed state r thetarangle, where r is the amplitude squeezing parameter and theta is the phase squeezing parameter, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0\nquad mathbfV = frac12left(cosh(2r)mathbfI - sinh(2r)mathbfR(theta)right)\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> squeezedstate(0.5, pi/4)\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 0.356044  0.415496\n 0.415496  1.18704\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.symplecticform-Tuple{N} where N<:Int64","page":"API","title":"Gabs.symplecticform","text":"symplecticform([T = Matrix{Float64},] modes<:Int)\n\nCompute the symplectic form matrix of size 2N x 2N, where N is given by modes.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.thermalstate-Union{Tuple{N}, Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, N}} where {Tm, Tc, N<:Int64}","page":"API","title":"Gabs.thermalstate","text":"thermalstate([Tm=Vector{Float64}, Tc=Matrix{Float64},] photons<:Int)\n\nGaussian state at thermal equilibrium, known as the thermal state. The mean photon number of the state is given by photons.\n\nMathematical description of a thermal state\n\nA thermal state barnrangle, where barn is the mean number of photons, is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0 quad mathbfV = left(barn + frac12right)mathbfI\n\nExample\n\njulia> thermalstate(4)\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 4.5  0.0\n 0.0  4.5\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.twosqueeze-Union{Tuple{N}, Tuple{Ts}, Tuple{Td}, Tuple{Type{Td}, Type{Ts}, N, N}} where {Td, Ts, N<:Real}","page":"API","title":"Gabs.twosqueeze","text":"twosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], r<:Real, theta<:Real)\ntwosqueeze([Tm=Vector{Float64}, Ts=Matrix{Float64}], r<:Real, theta<:Real, noise::Ts)\n\nGaussian operator that squeezes a two-mode vacuum state into a two-mode squeezed state, known as the two-mode squeezing operator. The amplitude and phase squeezing parameters  are given by r and theta, respectively. Noise can be added to the operation with noise.\n\nMathematical description of a two-mode squeezing operator\n\nA two-mode squeeze operator S_2(r theta) is defined by the operation S_2(r theta)0rangle = r thetarangle, where r and theta are the real amplitude and phase parameters, respectively. The operator  S_2(r theta) is characterized by  the displacement vector mathbfd and symplectic matrix mathbfS, expressed respectively as follows:\n\nmathbfd = mathbf0\nquad mathbfS = beginpmatrix\n                    cosh(r)mathbfI  -sinh(r)mathbfR(theta) \n                    -sinh(r)mathbfR(theta)  cosh(r)mathbfI \n                    endpmatrix\n\nwhere mathbfR(theta) is the rotation matrix.\n\nExample\n\njulia> twosqueeze(0.25, pi/4)\nGaussianUnitary for 2 modes.\ndisplacement: 4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\nsymplectic: 4×4 Matrix{Float64}:\n  1.03141    0.0       -0.178624  -0.178624\n  0.0        1.03141   -0.178624   0.178624\n -0.178624  -0.178624   1.03141    0.0\n -0.178624   0.178624   0.0        1.03141\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.vacuumstate-Union{Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}}} where {Tm, Tc}","page":"API","title":"Gabs.vacuumstate","text":"vacuumstate([Tm=Vector{Float64}, Tc=Matrix{Float64}])\n\nGaussian state with zero photons, known as the vacuum state.\n\nMathematical description of a vacuum state\n\nA vacuum state 0rangle is characterized by the mean vector mathbfbarx and covariance matrix mathbfV, expressed respectively as follows:\n\nmathbfbarx = mathbf0 quad mathbfV = mathbfI\n\nExample\n\njulia> vacuumstate()\nGaussianState for 1 mode.\nmean: 2-element Vector{Float64}:\n 0.0\n 0.0\ncovariance: 2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.wigner-Union{Tuple{T}, Tuple{GaussianState, T}} where T","page":"API","title":"Gabs.wigner","text":"wigner(state::GaussianState, x)\n\nCompute the Wigner function of an N-mode Gaussian state at x, a vector of size 2N.\n\n\n\n\n\n","category":"method"},{"location":"API/#Gabs.wignerchar-Union{Tuple{T}, Tuple{GaussianState, T}} where T","page":"API","title":"Gabs.wignerchar","text":"wignerchar(state::GaussianState, xi)\n\nCompute the Wigner characteristic function of an N-mode Gaussian state at xi, a vector of size 2N.\n\n\n\n\n\n","category":"method"},{"location":"API/#QuantumInterface.tensor-Union{Tuple{Tc}, Tuple{Tm}, Tuple{Type{Tm}, Type{Tc}, GaussianState, GaussianState}} where {Tm, Tc}","page":"API","title":"QuantumInterface.tensor","text":"tensor(state1::GaussianState, state2::GaussianState)\n\ntensor product of Gaussian states, which can also be called with ⊗.\n\nExample\n\njulia> coherentstate(1.0+im) ⊗ thermalstate(2)\nGaussianState for 2 modes.\nmean: 4-element Vector{Float64}:\n 1.4142135623730951\n 1.4142135623730951\n 0.0\n 0.0\ncovariance: 4×4 Matrix{Float64}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  2.5  0.0\n 0.0  0.0  0.0  2.5\n\n\n\n\n\n","category":"method"}]
}
